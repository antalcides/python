<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0053)http://www.etse.urv.es/~aoller/tutorial/tutorial.html -->
<HTML><HEAD><TITLE>Tutorial de</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.2800.1264" name=GENERATOR></HEAD>
<BODY background="Tutorial de_archivos/fondo.jpg"><B><FONT face="Comic Sans MS" 
size=5>
<P align=center>Tutorial de MatLab</P></B></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify></P></FONT><B><I><FONT face=Arial>
<P align=justify>1. ¿Qué es MatLab?</P></I></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>MatLab</B> es un programa interactivo para computación numérica 
y visualización de datos. Es ampliamente usado por Ingenieros de Control en el 
análisis y diseño, posee además una extraordinaria versatilidad y capacidad para 
resolver problemas en matemática aplicada, física, química, ingeniería, finanzas 
y muchas otras aplicaciones. Está basado en un sofisticado software de matrices 
para el análisis de sistemas de ecuaciones. Permite resolver complicados 
problemas numéricos sin necesidad de escribir un programa.</P>
<P align=justify>MATLAB es un entorno de computación y desarrollo de 
aplicaciones totalmente integrado orientado para llevar a cabo proyectos en 
donde se encuentren implicados elevados cálculos matemáticos y la visualización 
gráfica de los mismos. </P>
<P align=justify>MATLAB integra análisis numérico, cálculo matricial, proceso de 
señal y visualización gráfica en un entorno completo donde los problemas y sus 
soluciones son expresados del mismo modo en que se escribirían tradicionalmente, 
sin necesidad de hacer uso de la programación tradicional.</P>
<P align=justify>El nombre de MATLAB proviene de la contracción de los términos 
MATrix LABoratory y fue inicialmente concebido para proporcionar fácil acceso a 
las librerías LINPACK y EISPACK, las cuales representan hoy en dia dos de las 
librerías más importantes en computación y cálculo matricial.</P>
<P align=justify>MATLAB es un sistema de trabajo interactivo cuyo elemento 
básico de trabajo son las matrices. El programa permite realizar de un modo 
rápido la resolución numérica de problemas en un tiempo mucho menor que si se 
quisiesen resolver estos mismos problemas con lenguajes de programación 
tradicionales como pueden ser los lenguajes Fortran, Basic o C.</P>
<P align=justify>MATLAB goza en la actualidad de un alto nivel de implantación 
en escuelas y centros universitarios, así como en departamentos de investigación 
y desarrollo de muchas compañías industriales nacionales e internacionales. En 
entornos universitarios, por ejemplo, MATLAB se ha convertido en una herramienta 
básica, tanto para los profesionales e investigadores de centros docentes, como 
una importante herramienta para la impartición de cursos universitarios, tales 
como sistemas e ingenieria de control, álgebra lineal, proceso digital de 
imagen, señal, etc. En el mundo industrial, MATLAB está siendo utilizado como 
herramienta de investigación para la resolución de complejos problemas 
planteados en la realización y aplicación de modelos matemáticos en ingeniería. 
Los usos más característicos de la herramienta los encontramos en áreas de 
computación y cálculo numérico tradicional, prototipaje algorítmico, teoría de 
control automático, estadística, análisis de series temporales para el proceso 
digital de señal.</P>
<P align=justify>&nbsp;</P>
<P align=justify>MATLAB dispone también en la actualidad de un amplio abanico de 
programas de apoyo especializados, denominados Toolboxes, que extienden 
significativamente el número de funciones incorporadas en el programa principal. 
Estos Toolboxes cubren en la actualidad prácticamente casi todas las áreas 
principales en el mundo de la ingeniería y la simulación, destacando entre ellos 
el 'toolbox' de proceso de imágenes, señal, control robusto, estadística, 
análisis financiero, matemáticas simbólicas, redes neurales, lógica difusa, 
identificación de sistemas, simulación de sistemas dinámicos, etc.</P>
<P align=justify>Además también se dispone del programa Simulink que es un 
entorno gráfico interactivo con el que se puede analizar, modelizar y simular la 
dinámica de sistemas no lineales.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>1.1 Uso de Matrices</P></B></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>MatLab emplea matrices porque con ellas se puede describir 
infinidad de cosas de una forma altamente flexible y matemáticamente eficiente. 
Una matriz de pixeles puede ser una imagen o una película. Una matriz de 
fluctuaciones de una señal puede ser un sonido o una voz humana. Y tal vez más 
significativamente, una matriz puede describir una relación lineal entre los 
componentes de un modelo matemático. En este último sentido, una matriz puede 
describir el comportamiento de un sistema extremadamente complejo. Por ejemplo 
una matriz puede representar el vuelo de una avión a 40.000 pies de altura, o un 
filtro digital de procesamiento de señales.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>1.2 Origen de MatLab</P></B></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>MatLab fue originalmente desarrollado en lenguaje FORTRAN para 
ser usado en computadoras mainframe. Fue el resultado de los proyectos Linpack y 
Eispack desarrollados en el Argonne National Laboratory. Su nombre proviene de 
MATrix LABoratory. Al pasar de los años fue complementado y reimplementado en 
lenguaje C. Actualmente la licencia de MatLab es propiedad de MathWorks Inc 
.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>1.3 Plataformas</P></B></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>MatLab está disponible para una amplio número de plataformas: 
estaciones de trabajo SUN, Apollo, VAXstation y HP, VAX, MicroVAX, Gould, Apple 
Macintosh y PC AT compatibles 80386 o superiores. Opera bajo sistemas operativos 
UNIX, Macintosh y Windows.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>1.4 Productos</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>La empresa MathWorks ofrece MatLab como su principal producto 
para computación numérica, análisis y visualización de datos. También ofrece 
Simulink como un anexo a MatLab y que interactua con él en lenguaje de MatLab y 
lenguaje de bajo nivel C. Simulink es usado para simulación modelado no lineal 
avanzado. Se ofrecen además numerosas herramientas especiales en "Toolboxes" 
para resolver problemas de aplicaciones específicas, por ejemplo control, 
procesamiento de señales, redes neurales, etc. Estas herramientas son 
colecciones de rutinas escritas en MatLab.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face=Arial size=4>
<P>2. Librería de Aplicaciones de MATLAB</P></FONT><I><FONT face=Arial>
<P align=justify>&nbsp;</P>
<P align=justify>2.1 Signal Processing Toolbox </P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>MATLAB tiene una gran colección de funciones para el 
procesamiento de señal en el Signal Processing Toolbox. Este incluye funciones 
para: </P>
<UL>
  <P align=justify>
  <LI>Análisis de filtros digitales incluyendo respuesta en frecuencia, retardo 
  de grupo, retardo de fase.
  <P></P>
  <P align=justify></P>
  <LI>Implementación de filtros, tanto directo como usando técnicas en el 
  dominio de la frecuencia basadas en la FFT. 
  <P></P>
  <P align=justify></P>
  <LI>Diseño de filtros IIR, incluyendo Butterworth, Chebyschev tipo I, 
  Chebyshebv tipo II y elíptico. 
  <P></P>
  <P align=justify></P>
  <LI>Diseño de filtros FIR mediante el algorítmo óptimo de Parks-McClellan. 
  <P></P>
  <P align=justify></P>
  <LI>Procesamiento de la transformada rápida de Fourier FFT, incluyendo la 
  transformación para potencias de dos y su inversa, y transformada para no 
  potencias de dos.
  <P></P></LI></UL>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>2.2 The MATLAB C Math Library</P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>La MATLAB C Math Library proporciona al usuario la capacidad 
computacional de MATLAB en una libreria en formato objeto enlazable. El objetivo 
principal de la C Math Library es soportar el desarrollo de aplicaciones 'stand 
alone' utilizando MATLAB y su compilador. Puede ser utilizada independientemente 
de MATLAB por programadores avezados en lenguaje C que necesiten prestaciones 
computacionales robustas y de alto rendimiento.</P>
<P align=justify>Junto con el compilador de MATLAB, la C Math Library permitirá 
a los programadores de aplicaciones utilizar MATLAB para la creación de 
aplicaciones 'stand alone'. Para los usuarios clásicos de MATLAB, se elimina así 
cualquier necesidad de volver a reescribir algoritmos en lenguaje C para ser 
utilizada por programas externos. Para aquellos usuarios que sean nuevos en la 
tecnología MATLAB, esta tecnología ofrece una nueva vía para la reducción del 
tiempo de desarrollo y puesta a punto de aplicaciones.</P>
<P align=justify>La MATLAB C Math Library proporciona una amplia gama de 
funciones clásicas del programa MATLAB, proporcionadas como librerias objeto, 
incluyendo básicamente las siguientes categorías de funciones presentes en 
MATLAB y ficheros M compilados: </P>
<P align=justify>&nbsp;</P>
<UL>
  <P align=justify>
  <LI>Algebra lineal. 
  <P></P>
  <P align=justify></P>
  <LI>Funciones matemáticas elementales y especializadas. 
  <P></P>
  <P align=justify></P>
  <LI>Operadores lógicos y aritméticos. 
  <P></P>
  <P align=justify></P>
  <LI>Matrices elementales y manipulación de vectores. 
  <P></P>
  <P align=justify></P>
  <LI>Matrices especiales. 
  <P></P>
  <P align=justify></P>
  <LI>Estadística básica y análisis de datos. 
  <P></P>
  <P align=justify></P>
  <LI>Polinomios e interpolación. 
  <P></P>
  <P align=justify></P>
  <LI>Gestión de cadenas de caracteres. 
  <P></P>
  <P align=justify></P>
  <LI>Entradas y Salidas. 
  <P></P>
  <P align=justify></P>
  <LI>Gestión de memoria y errores. 
  <P></P></LI></UL>
<P align=justify>&nbsp;</P>
<P align=justify>(Nota: Las funciones del tipo Handle Graphics no están 
incluidas en la C Math Library).</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>2.2.1 Desarrollo de aplicaciones utilizando la MATLAB C Math 
Library</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>La construcción y desarrollo de aplicaciones utilizando esta 
librería es un proceso de amplias perspectivas una vez se tiene un dominio 
adecuado de su operativa. El producto está dividido en dos categorías (como 
librerías objeto): la librería (built-in library) contiene versiones de las 
funciones de MATLAB en lenguaje C del tipo numérico, lógico y utilidades. Por 
otra parte la librería de toolboxes (toolbox library) contiene versiones 
compiladas de la mayoría de ficheros M de MATLAB para cálculo numérico, análisis 
de datos y funciones de acceso a ficheros y matrices.</P>
<P align=justify>En equipos UNIX estas librerias pueden ser igualmente obtenidas 
como librerías de tipo estático (static libraries) o bien como librerías 
compartidas (shared libraries). Respecto al mundo PC, estas librerías pueden 
obtenerse como DLL's en el entorno Microsoft Windows o como librerias 
compartidas en equipos Apple MacIntosh.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>2.2.2 Utilización de MATLAB y de su 
compilador</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Para construir una aplicación del tipo 'stand alone' que 
incorpore código originalmente desarrollado como ficheros M de MATLAB , deberán 
seguirse los pasos siguientes:</P>
<OL>
  <P align=justify>
  <LI>Utilizar el compilador de MATLAB para convertir ficheros M en C mediante 
  la utilización de la instrucción mcc -e (la cual es externa a MATLAB). 
  <P></P>
  <P align=justify></P>
  <LI>Compilar el código C fuente en código objeto utilizando un compilador ANSI 
  C. 
  <P></P>
  <P align=justify></P>
  <LI>Enlazar el código resultante con la MATLAB C Math Library y con cualquier 
  tipo de ficheros y programas específicos que hayan sido previamente definidos 
  por el usuario. 
  <P></P></LI></OL>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>2.2.3 Velocidad y Precisión</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Los algoritmos utilizados en la MATLAB C Math Library han sido 
desarrollados por un grupo de renombrados expertos en programación algorítmica 
de funciones de tipo matemático (algebra lineal y cálculo numérico). Las 
funciones de álgebra lineal han sido obtenidas de las librerias mundialmente 
reconocidas LINPACK y EISPACK. La MATLAB C Math Library contiene más de 300 
funciones numéricas, lógicas y de utilidad. Todas estas funciones le permitirán 
operar en datos de tipo escalar, vectorial o matricial con la misma facilidad 
sintáctica.</P></FONT><FONT face="Comic Sans MS">
<P align=justify>&nbsp;</P><B>
<P align=justify>2.2.4 Lista parcial de funciones </P></FONT><FONT 
face="Comic Sans MS" size=3>
<P align=justify>Funciones matemáticas</P></B></FONT><U><FONT 
face="Comic Sans MS">
<P align=justify>Funcionales especiales y elementales </P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Funciones gamma, beta y elípticas. </P>
<P align=justify>Transformación de sistemas de coordenadas. </P>
<P align=justify>Matriz identidad y otras matrices elementales. </P>
<P align=justify>Matrices de Hilbert, Toeplitz, Vandermonde, Hadamard, etc. </P>
<P align=justify>Partes reales, imaginarias y complejas conjugadas. </P>
<P align=justify>Funciones trigonométricas y de potencias. </P></FONT><U><FONT 
face="Comic Sans MS">
<P align=justify>Algebra lineal numérica </P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Valores propios y descomposición de matrices. </P>
<P align=justify>Funciones generales de evaluación de matrices. </P>
<P align=justify>Determinantes, normas, rangos, etc. </P>
<P align=justify>Matrices inversas y factorización de matrices. </P>
<P align=justify>Matriz exponencial, logarítmica y raíces cuadradas. 
</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Polinomios e interpolación </P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Interpolación 1-D y 2-D. </P>
<P align=justify>Construcción polinomial. </P>
<P align=justify>Interpolación por splines cúbicos. </P>
<P align=justify>Diferenciación de polinomios. </P>
<P align=justify>Evaluación de polinomios. </P>
<P align=justify>Multiplicación y división de polinomios. </P>
<P align=justify>Residuos de polinomios y residuos. </P></FONT><U><FONT 
face="Comic Sans MS">
<P align=justify>Métodos numéricos no lineales </P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Búsqueda de ceros en funciones de una única variable.</P>
<P align=justify>Minimización de funciones de una o más variables.</P>
<P align=justify>Resolución numérica de integrales.</P>
<P align=justify>Solución numérica de ecuaciones diferenciales 
ordinarias.</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Estadística y análisis de Fourier</P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Convolución 1-D y 2-D.</P>
<P align=justify>Filtros digitales 1-D y 2-D.</P>
<P align=justify>Transformadas de Fourier 1-D y 2-D y su inversa.</P>
<P align=justify>Coeficientes de correlación y matrices de covarianza.</P>
<P align=justify>Deconvolución.</P>
<P align=justify>Magnitudes y ángulos de fase.</P>
<P align=justify>Funciones max, min, sum, mean y otras funciones de estadística 
básica.</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Operaciones algebráicas y lógicas</P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Suma, resta, multiplicación, división y potencias de 
matrices.</P>
<P align=justify>Matrix traspuesta.</P>
<P align=justify>Operadores lógicos AND, OR, NOT y XOR.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>2.2.5 Utilidades</P></B></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Gestión y mantenimiento de errores.</P>
<P align=justify>Conversión de tipos de datos Fortran.</P>
<P align=justify>Funciones de fecha y hora.</P>
<P align=justify>Clasificación de matrices.</P>
<P align=justify>Conversión de números a cadenas y viceversa.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>2.2.6 Requerimientos</P></B></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>La libreria MATLAB C Math Library cumple con la normativa 
estándar ANSI para compiladores C. </P>
<P align=justify>Finalmente, la librería trabajará con aquellos enlazadores que 
vienen suministrados con la mayoría de compiladores ANSI C.</P>
<P align=justify>&nbsp;</P>
<P align=justify></P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>2.3 THE MATLAB COMPILER TOOLBOX</P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>El nuevo compilador de MATLAB -The MATLAB Compiler- permite 
crear código C optimizado procedente de ficheros M -M files- de MATLAB. Este 
compilador puede ser utilizado de dos modos: </P>
<OL>
  <P align=justify>
  <LI>Como un generador MEX automático. Pueden convertirse ficheros M en 
  funciones C ejecutables que se ejecutaran desde dentro de MATLAB. Como un 
  generador de código C fuente. 
  <P></P>
  <P align=justify></P>
  <LI>Pueden construirse aplicaciones que se ejecutaran independientemente de 
  MATLAB. Estas aplicaciones externas requieren de la MATLAB C Math Library, que 
  está disponible separadamente. 
  <P></P></LI></OL>
<P align=justify>&nbsp;</P>
<P align=justify>Mediante la conversión automática de ficheros M en código C 
fuente, el compilador MATLAB elimina consumo de tiempo y la conversión manual de 
código.</P>
<P align=justify>Todo el proceso de conversión, compilación y enlazado se inicia 
a través de una simple instrucción de MATLAB.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>2.3.1 Generación Automática de ficheros 
MEX.</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>El compilador de MATLAB automatiza la creación de ficheros MEX 
de C (MATLAB Ejecutables).</P>
<P align=justify>Los ficheros MEX contienen código objeto que es dinámicamente 
enlazado como 'runtime' en el entorno MATLAB por el intérprete del programa.</P>
<P align=justify>El proceso en cuestión se realiza en tres pasos: </P>
<OL>
  <P align=justify>
  <LI>El compilador de MATLAB traduce las funciones MATLAB en sus funciones 
  equivalente en lenguaje C. 
  <P></P>
  <P align=justify></P>
  <LI>La instrucción MATLAB cmex llama al compilador y al enlazador del sistema 
  para construir un fichero MEX objeto. 
  <P></P>
  <P align=justify></P>
  <LI>El intérprete de MATLAB enlaza automáticamente la función de MATLAB como 
  'runtime'. 
  <P></P></LI></OL>
<P align=justify>Mientras se efectúa una conversión de los ficheros M en 
ficheros MEX, el compilador realiza llamadas a las rutinas de la libreria C para 
muchas de las instrucciones contenidas en el propio núcleo de MATLAB. Existen 
algunas funciones, incluyendo las rutinas 'Handle Graphics', para las cuales se 
generan de nuevo llamadas 'callbacks' a MATLAB. </P>
<P align=justify>Pueden convertirse convenientemente ficheros M en código fuente 
C para incorporarlos posteriormente en los ficheros externos desarrollados en 
lenguaje C, si ese es el caso. Esta opción es ideal para usuarios que quieren 
sacar la máxima ventaja de MATLAB desde cualquier otra aplicación o producir 
código C eficiente a partir de los algoritmos desarrollados con MATLAB. Los 
desarrollos del tipo 'stand-alone' requieren para ello de la MATLAB C Math 
Library. Obsérvese que las funciones gráficas de MATLAB no están incluidas.</P>
<P align=justify>Para construir aplicaciones 'stand-alone' se debería seguir los 
siguientes pasos: </P>
<OL>
  <P align=justify>
  <LI>Utilizar el compilador de MATLAB para convertir ficheros M en C con la 
  instrucción externa mcc -e. 
  <P></P>
  <P align=justify></P>
  <LI>Compilar el código C fuente en código objeto utilizando un compilador C. 
  <P></P>
  <P align=justify></P>
  <LI>Enlazar el código resultante con las librerías matemáticas C de MATLAB y 
  los ficheros específicos que dispongamos. 
  <P></P></LI></OL>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>2.3.2 Rendimiento del compilador</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Mediante la compilación de los ficheros M se puede obtener un 
rendimiento significativo. La velocidad de mejora de este rendimiento, depende 
fuertemente de cada aplicación. En algunos casos el rendimiento puede mejorar 
hasta en 200 veces la ejecución si la comparamos con el modo de trabajo 
interpretado del programa. Las operaciones matriciales y vectoriales ejecutadas 
desde MATLAB ya están fuertemente optimizadas en su diseño. Sin embargo, 
mediante la utilización del compilador se obtendrán significativas mejoras.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>2.3.3 Opciones de ajuste del rendimiento</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>El compilador de MATLAB ofrece varias opciones que permiten 
generar el programa final de la forma más eficiente. Por ejemplo, Ud. puede 
directamente: </P>
<UL>
  <P align=justify>
  <LI>Tratar todas las variables en ficheros como datos enteros y/o reales.
  <P></P>
  <P align=justify></P>
  <LI>Utilizar una variable concreta como variable escalar, vectorial, entera, 
  real o una combinación de estas. 
  <P></P>
  <P align=justify></P>
  <LI>Desactivar el control de parámetros de entrada y el redimensionamiento 
  dinámico de vectores. 
  <P></P></LI></UL>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>2.3.4 Requerimientos del sistema</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Para utilizar el compilador de MATLAB para crear ficheros MEX 
se necesita la versión de MATLAB 4.2c y tener instalado uno de los siguientes 
compiladores de lenguaje C:</P>
<P align=justify>PC/Microsoft Windows</P>
<P align=justify>Metaware High C/C++ V.3.0 o superior.</P>
<P align=justify>Watcom C V.10.0 o superior</P>
<P align=justify>Power MacIntosh</P>
<P align=justify>MetroWerks CodeWarrior C V.7</P>
<P align=justify>MPW MrC V.1.0b2 o PPCC version 1.0.5</P>
<P align=justify>680x0 MacIntosh</P>
<P align=justify>MPW C Versión 3.4</P>
<P align=justify>UNIX y VMS</P>
<P align=justify>&nbsp;</P>
<P align=justify>Cualquier compilador ANSI C (Nota: El compilador de SunOS 4.1.X 
no es un compilador ANSI C).</P>
<P align=justify>Cualquiera que sea el equipo informático que vaya a utilizarse 
para desarrollar aplicaciones 'stand alone' se requiere, además del compilador 
de MATLAB, que se tengan las MATLAB C Math Library y un compilador ANSI C.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>2.3.5 Limitaciones del código compilado</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Ciertas instrucciones, como load y eval, no están soportadas 
por el compilador de MATLAB . Este no puede generar código de los diagramas de 
bloques de SIMULINK. Los toolboxes de MATLAB pueden incluir ficheros MEX y otros 
componentes que no son compilables. </P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>2.4 SYMBOLIC MATH TOOLBOX</P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>El Toolbox de Matemática Simbólica, añade a MATLAB la capacidad 
de realizar cálculos simbólicos basados en MAPLE V © soportando además (The 
Extended Symbolic Math Toolbox) las librerías especializadas, y los programas 
realizados para este último. Entre otros, los principales tipos de operaciones 
soportados son los siguientes: </P>
<UL>
  <P align=justify>
  <LI>Algebra simbólica: Derivación, integración y simplificación de expresiones 
  matemáticas. 
  <P></P>
  <P align=justify></P>
  <LI>Algebra lineal exacta: Inversas, determinantes, autovalores y formas 
  canónicas de matrices simbólicas. 
  <P></P>
  <P align=justify></P>
  <LI>Aritmética de precisión variable: Evaluación de expresiones matemáticas 
  con diversos grados de precisión. 
  <P></P>
  <P align=justify></P>
  <LI>Resolución de ecuaciones: Resolución numérica y simbólica de ecuaciones 
  algebraicas y diferenciales. 
  <P></P>
  <P align=justify></P>
  <LI>Funciones matemáticas especiales: Evaluación de la mayoría de las 
  funciones utilizadas en matemáticas aplicadas. 
  <P></P></LI></UL>
<P align=justify>&nbsp;</P>
<P align=justify>Existen dos versiones del mismo Toolbox. The Basic Symbolic 
Math Toolbox es una colección de más de 50 funciones MATLAB las cuales permiten 
acceder al kernel de MAPLE utilizando la <U>Sintaxis</U> y el estilo del 
lenguaje MATLAB. The Extended Symbolic Math Toolbox aumenta esta funcionalidad 
incluyendo todas las características de programación de MAPLE, y el acceso a los 
paquetes de funciones de más de veinte campos de las matemáticas especiales 
aplicadas.</P>
<P align=justify>Es posible utilizar este Toolbox sin conocimiento previos de 
MAPLE, ya que los ficheros contenidos en él son totalmente autónomos. Sin 
embargo, si lo que se desea es obtener toda la potencia de cálculo del entorno, 
será necesario un amplio conocimiento del manejo y la programación de MAPLE </P>
<P align=justify></P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>2.5 Optimization Toolbox</P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>El toolbox de optimización consta de un conjunto de funciones 
que resuelven problemas de extremos, con o sin condiciones, de funciones reales 
las cuales son generalmente multivariables y no lineales.</P>
<P align=justify>Asimismo, posee funciones para la resolución de algunos tipos 
de problemas matriciales en extremos.</P>
<P align=justify>Resulta conveniente para una comprensión y mejor manejo de la 
toolbox poseer conocimientos básicos previos de análisis de funciones reales, 
matrices y teoría de extremos.</P>
<P align=justify>Algunas de las áreas básicas que cubre este toolbox para MATLAB 
son las siguientes: </P>
<UL>
  <P align=justify>
  <LI>Cálculo de un extremo local (máximo o mínimo) de una función real f(x), en 
  general multivariable y no lineal, sin imponer ninguna restricción o condición 
  a la solución. Como caso particular, se incluye una rutina especial para 
  problemas de mínimos cuadrados no lineales. 
  <P></P>
  <P align=justify></P>
  <LI>Cálculo de un extremo local (máximo o mínimo) de una función real f(x), en 
  general multivariable y no lineal, condicionado a que la solución satisfaga 
  ciertas condiciones de desigualdad (g(x)&lt;=0) y/o igualdad (g(x)=0). 
  <P></P></LI></UL>
<UL>
  <P align=justify>
  <LI>Problemas de aproximación a un conjunto de objetivos. 
  <P></P></LI></UL>
<UL>
  <P align=justify>
  <LI>Cálculo de soluciones de un sistema de ecuaciones continuas y, en general, 
  no lineales. 
  <P></P></LI></UL>
<UL>
  <P align=justify>
  <LI>Solución de problemas minimax. 
  <P></P>
  <P align=justify></P>
  <LI>Programación lineal. 
  <P></P>
  <P align=justify></P>
  <LI>Programación cuadrática. 
  <P></P>
  <P align=justify></P>
  <LI>Problemas de mínimos cuadrados no negativos.
  <P></P></LI></UL>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>2.6 Image Processing Toolbox</P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Este Toolbox proporciona a MATLAB de un conjunto de funciones 
que amplia las capacidades del producto para realizar desarrollo de aplicaciones 
y de nuevos algoritmos en el campo del proceso y análisis de imagenes. El 
entorno matemático y de creación de MATLAB es ideal para el procesado de 
imágenes, ya que estas imágenes son, al fin y al cabo, matrices. Este toolbox 
incorpora funciones para:</P>
<UL>
  <P align=justify>
  <LI>Diseño de filtros. 
  <P></P>
  <P align=justify></P>
  <LI>Mejora y retocado de imágenes. 
  <P></P>
  <P align=justify></P>
  <LI>Análisis y estadística de imágenes. 
  <P></P>
  <P align=justify></P>
  <LI>Operaciones morfológicas, geométricas y de color. 
  <P></P>
  <P align=justify></P>
  <LI>Transformaciones 2D.
  <P></P></LI></UL>
<P align=justify>El proceso de imágenes es un campo de trabajo absolutamente 
crucial para aquellos colectivos e industrias que estén trabajando en áreas como 
diagnóstico médico, astronomía, geofísica, ciencia medioambientales, análisis de 
datos en laboratorios, inspección industrial, etc. Los programas actuales de 
procesado y análisis de imágenes se clasifican actualmente en dos categorías: 
librerías de bajo nivel para programadores profesionales y paquetes de 
aplicación con capacidades limitadas de personalización. Ambos tipos de 
aplicaciones están, generalmente, pensados para tareas básicas de visualización 
de datos y 'rendering'. Sin embargo, muchos de ellos adolecen de la posibilidad 
de efectuar análisis numéricos de los mismos. El Image Processing Toolbox entra 
dentro de la categoría de familias de funciones que, desde el entorno de trabajo 
de MATLAB , permitirá al profesional efectuar una exploración exhaustiva y desde 
un punto de vista matemático de las imágenes y gráficos que se deseen tratar o 
analizar.</P>
<P align=justify>Algunas de las funciones más importantes incluidas dentro de 
este toolbox son las siguientes: </P>
<UL>
  <P align=justify>
  <LI>Análisis de imágenes y estadística.
  <P></P>
  <P align=justify></P>
  <LI>Diseño de filtros y recuperación de imágenes.
  <P></P>
  <P align=justify></P>
  <LI>Mejora de imágenes. 
  <P></P>
  <P align=justify></P>
  <LI>Operaciones morfológicas. 
  <P></P>
  <P align=justify></P>
  <LI>Definición de mapas de colores y modificación gráfica.
  <P></P>
  <P align=justify></P>
  <LI>Operaciones geométricas. 
  <P></P>
  <P align=justify></P>
  <LI>Transformación de imágenes. 
  <P></P>
  <P align=justify></P>
  <LI>Proceso de bloques 
  <P></P></LI></UL>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>2.7 Neural Network Toolbox</P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Este toolbox proporciona funciones para el diseño, 
inicialización, simulación y entrenamiento de los modelos neuronales de uso más 
extendido en la actualidad: Perceptrón, redes lineales, redes de 
retropropagación, redes de base radial, aprendizaje asociativo y competitivo, 
aplicaciones autoorganizativas, aprendizaje de cuantización vectorial, redes de 
Elman y redes de Hopfield.</P>
<P align=justify>Mediante la inclusión de un amplio abanico de funciones y 
procedimientos escritos para MATLAB, el usuario puede mediante el Neural Network 
Toolbox efectuar el diseño de arquitecturas complejas, combinando los modelos 
que ya estan proporcionados por defecto en el toolbox. Asimismo, el usuario 
puede definir sus propias funciones de transferencia e inicialización, reglas de 
aprendizaje, funciones de entrenamiento y estimación de error para usarlas 
posteriormente con las funciones básicas.</P>
<P align=justify>El toolbox, aporta las facilidades y prestaciones gráficas de 
MATLAB para el estudio del comportamiento de las redes: visualización gráfica de 
la matriz de pesos y vector de desplazamiento mediante diagramas de Hinton, 
representación de errores a lo largo del entrenamiento, mapas de superficie de 
error en función de pesos y vector de desplazamiento, etc. Estos gráficos 
resultan muy útiles en el estudio de la convergencia y estabilidad de los 
algoritmos de aprendizaje. Este toolbox incluye un manual de introducción al 
campo de las redes neuronales junto con una colección de demostraciones y 
aplicaciones muy didácticas, útiles para el estudio y la profundización en las 
cuestiones fundamentales de los paradigmas de redes neuronales básicos. 
Asimismo, se proporcionan las referencias bibliográficas más significativas 
referidas a los distintos modelos que aparecen en la aplicación.</P>
<P align=justify>A pesar de que el estudio de las redes neuronales se inició ya 
hace algunas decadas, las primeras aplicaciones sólidas dentro de este campo no 
han tenido lugar hasta hace unos doce años y aun ahora constituyen un área de 
investigación en rápido desarrollo. Este toolbox tiene por tanto una orientación 
diferente a aquellos destinados a campos como el de sistemas de control u 
optimización donde la terminología, fundamentos matemáticos y procedimientos de 
diseño estan ya firmemente establecidos y se han aplicado durante años. Este 
toolbox pretende que sea utilizado para la valoración y diseño de diseños 
neuronales en la industria y sobre todo en educación e investigación.</P>
<P align=justify>Esta herramienta tiene el soporte de MATLAB 4.2c y SIMULINK. La 
librería de SIMULINK contiene modelos de capas de redes neuronales de cada tipo 
de neurona implementada en el toolbox de redes neuronales. Es posible por tanto 
diseñar sistemas SIMULINK para simular redes neuronales creadas usando esta 
herramienta. Simplemente, las capas se conectan de acuerdo con la arquitectura 
de la red y se proporcionan como entrada a la caja de diálogo de cada capa la 
matriz de pesos apropiada y el vector de desplazamiento. Usando el generador de 
código C de SIMULINK es posible generar automáticamente el código 
correspondiente a un diseño neuronal.</P>
<P align=justify>Dentro de las aplicaciones básicas de este toolbox, cabe 
destacar aquellas que están orientadas a aquellas que se enmarcan dentro del 
campo de la industria aeroespacial y automoción (simulación, sistemas de 
control, autopilotaje), banca, defensa (reconocimiento de patrones, 
procesamiento de señales, identificación de imágenes, extracción de 
características, compresión de datos), electrónica (control de procesos, 
análisis de errores, modelado no lineal, síntesis de voz, visión por ordenador), 
economía (análisis financiero, análisis predictivo), industria (control de 
procesos, identificación en tiempo real, sistemas de inspección), medicina, 
robótica (control de trayectorias, sistemas de visión), reconocimiento y 
síntesis del habla, telecomunicaciones (control de datos e imágenes, servicios 
de información automatizada, traducción del lenguaje hablado en tiempo real, 
diagnosis, sistemas de enrutamiento), etc. El toolbox contiene muchos ejemplos 
de algunas de estas aplicaciones.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>2.8 NON LINEAR CONTROL DESIGN TOOLBOX</P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Se trata del primer producto comercialmente disponible en la 
actualidad para el diseño de controladores automáticos en entornos de sistemas 
no lineales. Este nuevo toolbox está pensado para ser utilizado exhaustivamente 
por ingenieros que diseñan controladores para industrias avanzadas, destacando 
el sector del automóvil, ingenieria aeroespacial, control de procesos y empresas 
petroquímicas. Según indica Jim Tung, Vicepresidente del área de desarrollo de 
The MathWorks Group, Inc. "El proceso de aproximación tradicional en el diseño 
de controladores en sistemas no lineales ha sido hasta la fecha linealizarlos de 
algún modo para aplicar posteriomente un método de diseño lineal que requiere de 
importantes ajustes manuales. El toolbox NCD permite por primera vez a los 
ingenieros de control diseñar directamente sus controladores en un ambiente no 
lineal, obviando la aproximación lineal y otros procedimientos auxiliares que 
antes se necesitaban de modo imperativo.</P>
<P align=justify>Los resultados ahora son de elevada calidad, controladores más 
robustos y un ciclo de diseño mucho más rápido.</P>
<P align=justify>El toolbox NCD extiende, además, las prestaciones que incorpora 
SIMULINK, el entorno de desarrollo de diagramas de bloques para la modelación y 
análisis de sistemas dinámicos de The MathWorks, Inc. El usuario puede incluir 
uno o más bloques NCD en el sistema y describir posteriormente de modo 
totalmente gráfico las restricciones, tolerancias y límites de permisividad de 
cada uno de estos bloques. Los métodos avanzados de optimización y la simulación 
del proceso son posteriormente analizados y ajustados mediante la inclusión de 
unas ciertas variables de contorno para poder obtener los tiempos de respuesta 
deseados. Este toolbox puede ser utilizado para ajustar una amplia variedad de 
controladores que se utilicen en un sistema, destacando los controladores PID, 
LQR, LQG y estructuras H infinito. El diseñador de sistemas puede utilizar el 
método de Montecarlo para el diseño y análisis de controladores robustos, 
siempre que se detecten determinadas variaciones en los componentes del sistema. 
</P>
<P align=justify>El toolbox NCD es un componente avanzado del entorno integrado 
de desarrollo que ofrecen a los especialistas los programas MATLAB y SIMULINK. 
Por ello, los diseñadores podrán beneficiarse de muchos de los toolboxes 
desarrollados para este entorno en materia de diseño de sistemas lineales.</P>
<P align=justify>Por ejemplo, podrán utilizarse toolboxes para el análisis de 
sistemas lineales para el diseño inicial; posteriormente, podrán utilizarse 
modelos no lineales más sofisticados utilizando SIMULINK.</P>
<P align=justify>Además, puede invocarse NCD para un mejor ajuste paramétrico y 
para la optimización de los controladores. Este toolbox se encuentra actualmente 
disponible para una amplia variedad de plataformas informáticas, destacando 
ordenadores personales tipo PC o Apple MacIntosh, numerosas estaciones UNIX y 
ordenadores Digital VAX VMS.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>2.9 NAG FOUNDATION TOOLBOX</P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Este toolbox proporciona un acceso interactivo, desde dentro de 
MATLAB, a un amplio conjunto de funciones matemáticas y estadísticas contenidas 
en las clásicas NAG Fortran Libraries de la empresa The Numerical Algorithms 
Group Incorpora más de 200 ficheros M, los cuales cubren un amplio espectro de 
áreas de interés, entre las que cabe destacar optimización, ecuaciones 
diferenciales ordinarias y en derivadas parciales, cuadratura, estadística, etc. 
La NAG Foundation Toolbox añade también rutinas concretas para campos 
específicos tales como la resolución de problemas con condiciones de contorno, 
problemas de cuadratura adaptativa multidimensional, ajuste de curvas y 
superficies y el acceso a los algoritmos LAPACK para la resolución de ecuaciones 
lineales. Los nombre de las funciones han sido directamente tomados de las 
especificaciones de función clásica que añade The Numerical Algorithms Group 
para sus librerías. Como resultado de esto, aquellos usuarios de las librerías 
Fortran de NAG que a la vez sean usuarios de MATLAB, encontraran bastante cómodo 
acceder a las rutinas NAG utilizando la nomenclatura original.</P>
<P align=justify>La NAG Foundation Toolbox es resultado de la colaboración 
corporativa que actualmente están llevando a cabo The MathWorks Group y The 
Numerical Algoriths Group para proporcionar un rápido acceso desde MATLAB a un 
importante de rutinas matemáticas contenidas en la NAG Foundation Library. 
Actualmente, este toolbox incorpora 250 rutinas matemáticas.</P>
<P align=justify>Algunas de las áreas de cobertura de la NAG Foundation Toolbox 
son las siguientes: </P>
<UL>
  <P align=justify>
  <LI>Ceros de polinomios 
  <P></P>
  <P align=justify></P>
  <LI>Raíces de una o más ecuaciones de tipo trascendental. 
  <P></P>
  <P align=justify></P>
  <LI>Suma de series. 
  <P></P>
  <P align=justify></P>
  <LI>Cuadraturas. 
  <P></P>
  <P align=justify></P>
  <LI>Ecuaciones diferenciales ordinarias. 
  <P></P>
  <P align=justify></P>
  <LI>Ecuaciones diferenciales en derivadas parciales. 
  <P></P>
  <P align=justify></P>
  <LI>Estadística no paramétrica. 
  <P></P>
  <P align=justify></P>
  <LI>Análisis de series temporales. 
  <P></P>
  <P align=justify></P>
  <LI>Rutinas de clasificación. 
  <P></P>
  <P align=justify></P>
  <LI>Aproximación de funciones especiales. 
  <P></P>
  <P align=justify></P>
  <LI>Aproximación de curvas y superficies. 
  <P></P>
  <P align=justify></P>
  <LI>Maximización y minimización de funciones. 
  <P></P>
  <P align=justify></P>
  <LI>Factorización de matrices. 
  <P></P>
  <P align=justify></P>
  <LI>Valores y vectores propios. 
  <P></P>
  <P align=justify></P>
  <LI>Resolución de ecuaciones lineales simultáneas. 
  <P></P>
  <P align=justify></P>
  <LI>Ecuaciones lineales (LAPACK). 
  <P></P>
  <P align=justify></P>
  <LI>Estadística básica. 
  <P></P>
  <P align=justify></P>
  <LI>Análisis de correlación y regresiones. 
  <P></P>
  <P align=justify></P>
  <LI>Métodos multivariantes. 
  <P></P>
  <P align=justify></P>
  <LI>Generación de números aleatorios. 
  <P></P></LI></UL>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>3. Iniciando MatLab</P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Después de ejecutar el programa MatLab desde el sistema 
operativo empleado, por ejemplo haciendo doble click sobre el icono de MatLab en 
ambientes Windows, aparece el indicador de comandos el cual está listo para 
recibir instrucciones en lenguaje MatLab. Este indicador es de la siguiente 
forma: </P></FONT><FONT size=2>
<P align=justify>&gt;&gt;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Al iniciar el uso de MatLab están disponibles dos comandos de 
ayuda y demostración. Para ejecutarlos se escribe el comando en la línea de 
comandos después del símbolo &gt;&gt; y se presiona la tecla Enter. Por 
ejemplo:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;help</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>permite obtener una ayuda sobre los diferentes comandos de 
MatLab.</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;demo</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>hace una demostración de las diferentes aplicaciones de 
MatLab.</P>
<P align=justify>Para cerrar o finalizar el uso de MatLab se usa el comando 
</FONT><FONT size=2>quit</FONT><FONT face="Comic Sans MS" 
size=2>.</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;quit</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>4. Uso de comandos </P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>La primera forma de interactuar con MatLab es a través de la 
línea de comandos. Puede ejecutarse un comando si este está escrito después del 
símbolo &gt;&gt; y se presiona la tecla Enter.</P>
<P align=justify>MATLAB trabaja esencialmente con matrices numéricas 
rectangulares. La manera más fácil de entrar matrices pequeñas es enumerando los 
elementos de ésta de tal manera que:</P>
<UL>
  <P align=justify>
  <LI>los elementos estén separados por blancos ó comas. 
  <P></P></LI></UL>
<UL>
  <P align=justify>
  <LI>los elementos estén cerrados entre corchetes, [ ]. 
  <P></P>
  <P align=justify></P>
  <LI>muestre el final de cada fila con ; (punto y coma). 
  <P></P></LI></UL>
<P align=justify>Ejemplo:</P></FONT><FONT size=2>
<P align=justify>A = [ 1 2 3; 4 5 6; 7 8 9 ]</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>resultaría en la matriz</P></FONT><FONT size=2>
<P align=justify>A = </P>
<P align=justify>1 2 3</P>
<P align=justify>4 5 6</P>
<P align=justify>7 8 9</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>MATLAB guarda esta matriz para utilizarla luego bajo el nombre 
de A.</P>
<P align=justify>Si la matriz a introducir es muy grande se puede utilizar el 
siguiente formato:</P>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>A = [1 2 3</P>
<P align=justify>4 5 6</P>
<P align=justify>7 8 9]</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>El comando</FONT><FONT size=2> load </FONT><FONT 
face="Comic Sans MS" size=2>y la función </FONT><FONT size=2>fread</FONT><FONT 
face="Comic Sans MS" size=2> pueden leer matrices generadas en sesiones 
anteriores ó generadas por otros programas.</P>
<P align=justify>Ya que MatLab se basa en el álgebra de matrices como ejemplo 
crearemos una matriz. Estas pueden estar formadas por un sólo elementos 
(escalar), por una fila o una columna (vector) o por una serie de filas y 
columnas (matriz propiamente dicha).</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;A=1</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>define A como un escalar de valor 1. Al definir A 
automáticamente MatLab presenta en pantalla su valor.</P></FONT><FONT size=2>
<P align=justify>A =</P>
<P align=justify>1</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Para no presentar el valor de la variable creada, debe 
agregarse punto y coma (;) al final del comando.</P>
<P align=justify>Después de crear una variable, puede presentarse su valor en 
pantalla escribiendo la variable después del prompt (&gt;&gt;).</P></FONT><FONT 
size=2>
<P align=justify>&gt;&gt;A</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Se pueden redefinir variables, por ejemplo:</P></FONT><FONT 
size=2>
<P align=justify>&gt;&gt;A=[1 2 3]</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>define A como un vector de tres elementos, A(1)=1, A(2)=2 y 
A(3)=3. Estos elementos deben separase con espacios en blanco o comas (,).</P>
<P align=justify>Para definir una matriz se deben separar las filas con punto y 
coma (;) o con retorno (Enter).</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;A=[1 2 3; 4 5 6]</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>o</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;A=[1 2 3</P>
<P align=justify>4 5 6]</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>ambos comandos producen el mismo efecto:</P></FONT><FONT 
size=2>
<P align=justify>A =</P>
<P align=justify>1 2 3</P>
<P align=justify>4 5 6</P></FONT><B><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>4.1 Elementos de matrices</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Los elementos de una matriz pueden ser cualquier expresión de 
MATLAB.</P>
<P align=justify>Ejemplo: </P></FONT><FONT size=2>
<P align=justify>x = [-1.3,sqrt(3),(1+2+3) *4/5]</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>resultaría en</P>
<P align=justify>x = </P>
<P align=justify>-1.3000 1.7321 4.8000</P>
<P align=justify>&nbsp;</P>
<P align=justify>Nos podemos referir a elementos individuales de la matriz con 
índices entre paréntesis.</P>
<P align=justify>Ejemplo: En el ejemplo anterior</P></FONT><FONT size=2>
<P align=justify>x(4) = abs(x(1))</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>resultaría </P></FONT><FONT size=2>
<P align=justify>x = </P>
<P align=justify>-1.3000 1.7321 4.8000 0 1.3000</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Para añadir otra fila a la matriz A de arriba podemos hacer lo 
siguiente:</P></FONT><FONT size=2>
<P align=justify>r = [10 11 12];</P>
<P align=justify>A = [A; r]</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>y resultaría </P></FONT><FONT size=2>
<P align=justify>A = </P>
<P align=justify>1 2 3 </P>
<P align=justify>4 5 6</P>
<P align=justify>7 8 9</P>
<P align=justify>10 11 12</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>&nbsp;</P>
<P align=justify>4.2 Instrucciones de MATLAB y Variables</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Si omites el nombre de la variable y el signo "=", MATLAB 
automáticamente crea la variable </FONT><FONT size=2>ans</FONT><FONT 
face="Comic Sans MS" size=2> para guardar el resultado. También distingue las 
letras mayúsculas de las minúsculas. Todos los nombres de funciones deben ser en 
letras minúsculas.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>4.3 Obteniendo Información del Espacio de 
Trabajo</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Los ejemplos que hemos dado se han guardado en variables que 
están en el espacio de trabajo de MATLAB. Para listar las variables en el 
espacio de trabajo se utiliza el comando </FONT><FONT size=2>who</FONT><FONT 
face="Comic Sans MS" size=2>. Para ver información adicional acerca de estas 
variables se utiliza el comando </FONT><FONT size=2>whos</FONT><FONT 
face="Comic Sans MS" size=2>. </P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>4.4 Variables Permanentes</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Las variables permanentes son aquellas con significado 
especial, y que no se pueden eliminar. Estas son por ejemplo las variables 
</FONT><FONT size=2>ans</FONT><FONT face="Comic Sans MS" size=2> y </FONT><FONT 
size=2>eps</FONT><FONT face="Comic Sans MS" size=2>. </P>
<P align=justify>La variable </FONT><FONT size=2>eps</FONT><FONT 
face="Comic Sans MS" size=2> es una tolerancia para determinar. Por ejemplo la 
singularidad y el rango. Su valor inicial es la distancia de 1.0 al próximo 
número de punto flotante mayor. </P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>4.5 Funciones</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Las funciones que utiliza MATLAB son intrínsecas al procesador 
de éste. Otras funciones están disponibles en la librería externa de archivos-M. 
Además de éstas funciones todo usuario también puede crear otras funciones. 
Puedes combinar las funciones de acuerdo a tu necesidad.</P>
<P align=justify>Ejemplo:</P></FONT><FONT size=2>
<P align=justify>x = sqrt(log(z))</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>4.6 Saliendo y Guardando el Espacio de 
Trabajo</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Para salir de MATLAB se escribe </FONT><FONT 
size=2>quit</FONT><FONT face="Comic Sans MS" size=2> ó </FONT><FONT 
size=2>exit</FONT><FONT face="Comic Sans MS" size=2>. Al terminar una sesión de 
MATLAB, las variables en el espacio de trabajo se borran. Si deseas guardar tu 
espacio de trabajo escribes </FONT><FONT size=2>save</FONT><FONT 
face="Comic Sans MS" size=2>. </P></FONT><FONT size=2>
<P align=justify>save</FONT><FONT face="Comic Sans MS" size=2> guarda todas las 
variables en un archivo llamado matlab.mat. </P>
<P align=justify>Se puede utilizar </FONT><FONT size=2>save </FONT><FONT 
face="Comic Sans MS" size=2>y </FONT><FONT size=2>load</FONT><FONT 
face="Comic Sans MS" size=2> con otros nombres de archivos, ó para guardar solo 
variables seleccionadas</P>
<P align=justify>Ejemplo: </P></FONT><FONT size=2>
<P align=justify>save temp X Y Z</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Este ejemplo guarda las variables X, Y, Z en el archivo 
temp.mat. Usando el comando </FONT><FONT size=2>load temp</FONT><FONT 
face="Comic Sans MS" size=2> las obtienes nuevamente del archivo temp.mat. 
</FONT><FONT size=2>load</FONT><FONT face="Comic Sans MS" size=2> y </FONT><FONT 
size=2>save</FONT><FONT face="Comic Sans MS" size=2> también pueden importar y 
exportar información de archivos ASCII.</P><B>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>4.7 Manipulación de Vectores y Matrices</P></B><U>
<P align=justify>Generando Vectores</P></U></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Los dos puntos, :, son importantes en MATLAB. Por 
ejemplo</P></FONT><FONT size=2>
<P align=justify>x = 1:5</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>genera un vector fila que contiene los números enteros del 1 al 
5:</P></FONT><FONT size=2>
<P align=justify>x =</P>
<P align=justify>1 2 3 4 5</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>No necesariamente se tiene que incrementar por números enteros, 
pueden ser decimales, números negativos ó constantes.</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Índices</P></U>
<P align=justify>Podemos referirnos a elementos individuales de matrices 
encerrando sus índices en paréntesis. </P>
<P align=justify>Ejemplo: </P></FONT><FONT size=2>
<P align=justify>A = </P>
<P align=justify>1 2 3</P>
<P align=justify>4 5 6</P>
<P align=justify>7 8 9</P>
<P align=justify>&nbsp;</P>
<P align=justify>A(3, 3) = A(1, 3) + A(3, 1)</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>resultaría </P></FONT><FONT size=2>
<P align=justify>A = </P>
<P align=justify>1 2 3</P>
<P align=justify>4 5 6</P>
<P align=justify>7 8 10</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Un índice puede ser un vector. Si x y v son vectores, entonces 
x(v) es [x(v(1)), x(v(2)), ...,x(v(n))]. Para matrices, los índices de vectores 
permiten acceso a submatrices contiguas y no-contiguas.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Por ejemplo, suponga que A es una matriz 10 por 10. 
Entonces</P></FONT><FONT size=2>
<P align=justify>A(1:5, 3)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>especifica la submatriz 5 x 1, ó vector columna, que consiste 
de los primeros cinco elementos en la tercera columna de A. </P>
<P align=justify>También</P></FONT><FONT size=2>
<P align=justify>A(1:5, 7:10)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>es la submatriz 5 x 4 de las primeras cinco filas y las últimas 
cuatro columnas.</P>
<P align=justify>Utilizando solo los dos puntos denota todo lo correspondiente a 
la fila ó columna. Podríamos tener una instrucción como:</P></FONT><FONT size=2>
<P align=justify>A(:, [3 5 10]) = B(:, 1:3)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>que reemplaza la tercera, quinta y décima columna de A con las 
primeras tres columnas de B.</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Manipulación de Matrices</P></U></FONT><FONT size=2>
<P align=justify>diag</FONT><FONT face="Comic Sans MS" size=2> - extrae ó crea 
una diagonal </P>
<P align=justify></FONT><FONT size=2>tril</FONT><FONT face="Comic Sans MS" 
size=2> - parte inferior triangular </P></FONT><FONT size=2>
<P align=justify>triu</FONT><FONT face="Comic Sans MS" size=2> - parte superior 
triangular </P>
<P align=justify>' - transposición </P><B>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>4.8 Operaciones de Matrices </P></B><U>
<P align=justify>Matrices Transpuestas</P></U></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>El caracter ' (apóstrofe) denota la transpuesta de la matriz. 
Si tenemos la matriz A y llamamos B = A', B es la transpuesta de la matriz 
A.</P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Sumando y Restando Matrices </P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Las operaciones suma (+) y resta (-) son definidas para las 
matrices siempre y cuando éstas tengan la misma dimensión. Es decir, si A y B 
son matrices 3 x 3, entonces A + B se puede calcular.</P>
<P align=justify>Las operaciones suma y resta también está definidas si uno de 
los operandos es un escalar, es decir, una matriz 1 x 1.</P>
<P align=justify>Ejemplo: </P></FONT><FONT size=2>
<P align=justify>x = </P>
<P align=justify>-1</P>
<P align=justify>0</P>
<P align=justify>2</P>
<P align=justify>&nbsp;</P>
<P align=justify>y = x - 1</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>resultaría </P>
<P align=justify>y = </P>
<P align=justify>-2</P>
<P align=justify>-1</P>
<P align=justify>1</P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;A=[1 2 3;4 5 6]; B=[6 5 4; 3 2 1];</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>define las matrices A y B. Para sumarlas se escribe la 
operación:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;A+B</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>El resultado de la operación es por defecto almacenado en la 
variable ans e inmediatamente presentado en pantalla:</P></FONT><FONT size=2>
<P align=justify>ans =</P>
<P align=justify>7 7 7</P>
<P align=justify>7 7 7</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Para almacenar la suma de A y B en la variable 
C:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;C=A+B</P>
<P align=justify>C =</P>
<P align=justify>7 7 7</P>
<P align=justify>7 7 7</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Multiplicando Matrices </P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>La operación de multiplicación de matrices está definida 
siempre que el número de columnas de la primera matriz sea igual a el número de 
filas de la segunda matriz.</P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Producto escalar</P></U></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>El producto interior (producto escalar ó producto punto) se 
consigue de la siguiente manera:</P>
<P align=justify>x' * y</P>
<P align=justify>asumiendo que x y y son vectores columnas. Note que y' * x 
produce el mismo resultado.</P><U>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>Producto de una matriz por un vector</P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>El producto de una matriz y un vector es un caso especial del 
producto matriz-matriz y naturalmente, un escalar como pi, puede multiplicar, ó 
ser multiplicado por, cualquier matriz. </P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Dividiendo Matrices</P></U></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>En división de matrices, si A es una matriz cuadrada 
no-singular, entonces A\B y B/A corresponden a la multiplicación izquierda y 
derecha de B por el inverso de A, esto es, inv(A) * B y B * inv(A) 
respectivamente. El resultado es obtenido directamente sin la computación del 
inverso. </P>
<P align=justify>&nbsp;</P>
<P align=justify>X = A\B es una solución a A * X = B </P>
<P align=justify>X = B/A es una solución a X * A = B</P>
<P align=justify>&nbsp;</P>
<P align=justify>A\B es definido cuando B tiene la misma cantidad de filas que 
A. Si A es cuadrada, el método usado es la Eliminación Gaussiana. El resultado 
es una matriz X con las mismas dimensiones que B.</P>
<P align=justify>Si A no es cuadrada, se factoriza utilizando la 
ortogonalización de Householder con pivoteo de columnas.</P>
<P align=justify>Los factores son usados para resolver sistemas de ecuaciones 
sub-determinados y sobre-determinados. El resultado es una matriz X m-por-n 
donde m es el número de columnas de A y n es el número de columnas de B. Cada 
columna de X tiene, al menos, k componentes diferentes de cero, donde k es el 
rango efectivo</P>
<P align=justify>de A.</P>
<P align=justify>&nbsp;</P>
<P align=justify>B/A esta definido en términos de A\B por B/A = (A'\B') '.</P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Usando Exponentes con Matrices </P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>La expresión A^n eleva A a la n-ésima potencia y esta definido 
si A es una matriz cuadrada y n un escalar.</P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Funciones Matriciales Trascendentales y 
Elementales</P></U></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>MATLAB considera expresiones como exp(A) y sqrt(A) como 
operaciones de arreglos, definidas en los elementos individuales de A. También 
puede calcular funciones trascendentales de matrices, como la matriz exponencial 
y la matriz logarítmica. Estas operaciones especiales están definidas solamente 
para matrices cuadradas.</P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Otras funciones elementales de matrices son: 
</P></U></FONT><FONT size=2>
<P align=justify>poly</FONT><FONT face="Comic Sans MS" size=2> - polinomio 
característico</P></FONT><FONT size=2>
<P align=justify>det</FONT><FONT face="Comic Sans MS" size=2> - 
determinante</P></FONT><FONT size=2>
<P align=justify>trace</FONT><FONT face="Comic Sans MS" size=2> - 
traza</P></FONT><FONT size=2>
<P align=justify>kron</FONT><FONT face="Comic Sans MS" size=2> - producto 
tensorial de Kronecker</P></FONT><FONT size=2>
<P align=justify>eig</FONT><FONT face="Comic Sans MS" size=2> - calcula los 
valores propios de la matriz</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>4.9 Operaciones de Arreglos </P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>El término operaciones de arreglo se refiere a las operaciones 
de aritmética elemento por elemento. Un punto (.) antes de un operador indica 
una operación de arreglos elemento por elemento.</P><U>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>Suma y Resta de Arreglos</U> </P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Para suma y resta, las operaciones de arreglos y las 
operaciones de matrices son iguales.</P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Multiplicación y División de Arreglos</P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>El símbolo .* denota multiplicación de arreglos elemento por 
elemento.</P>
<P align=justify>Ejemplo: </P></FONT><FONT size=2>
<P align=justify>x = [1 2 3]; y = [4 5 6];</P>
<P align=justify>z = x. *y </P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>resulta </P></FONT><FONT size=2>
<P align=justify>z = </P>
<P align=justify>4 10 18</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Las expresiones A./B y A.\B dan los cocientes de los elementos 
individuales.</P>
<P align=justify>Ejemplo: </P></FONT><FONT size=2>
<P align=justify>z = x.\y</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>resulta </P></FONT><FONT size=2>
<P align=justify>z =</P>
<P align=justify>4.0000 2.5000 2.0000</P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS">
<P align=justify>Exponentes con Arreglos </P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>El símbolo .^ denota exponenciación elemento por elemento.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>4.10 Ejemplos: Operaciones Aritméticas </P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplos:</P></B></FONT><FONT size=2>
<P align=justify>&gt;&gt; 1/2</P>
<P align=justify>ans =</P>
<P align=justify>0.5000</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; 2\1</P>
<P align=justify>ans =</P>
<P align=justify>0.5000 </P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a=[2;1;2]</P>
<P align=justify>a =</P>
<P align=justify>2</P>
<P align=justify>1</P>
<P align=justify>2</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; b=[1;2;3]</P>
<P align=justify>b =</P>
<P align=justify>1</P>
<P align=justify>2</P>
<P align=justify>3</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a'</P>
<P align=justify>ans =</P>
<P align=justify>2 1 2</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; b'</P>
<P align=justify>ans =</P>
<P align=justify>1 2 3</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a*b</P>
<P align=justify>??? Error using ==&gt; *</P>
<P align=justify>Inner matrix dimensions must agree.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a.*b</P>
<P align=justify>ans =</P>
<P align=justify>2</P>
<P align=justify>2</P>
<P align=justify>6</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a*b'</P>
<P align=justify>ans =</P>
<P align=justify>2 4 6</P>
<P align=justify>1 2 3</P>
<P align=justify>2 4 6</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a.*b'</P>
<P align=justify>??? Error using ==&gt; .*</P>
<P align=justify>Matrix dimensions must agree.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a*3</P>
<P align=justify>ans =</P>
<P align=justify>6</P>
<P align=justify>3</P>
<P align=justify>6</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; b.*3</P>
<P align=justify>ans =</P>
<P align=justify>3</P>
<P align=justify>6</P>
<P align=justify>9</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a/3</P>
<P align=justify>ans =</P>
<P align=justify>0.6667</P>
<P align=justify>0.3333</P>
<P align=justify>0.6667</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a./3</P>
<P align=justify>ans =</P>
<P align=justify>0.6667</P>
<P align=justify>0.3333</P>
<P align=justify>0.6667</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a^b</P>
<P align=justify>??? Error using ==&gt; ^</P>
<P align=justify>Matrix dimensions must agree.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a.^b</P>
<P align=justify>ans =</P>
<P align=justify>2</P>
<P align=justify>1</P>
<P align=justify>8</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a^2</P>
<P align=justify>??? Error using ==&gt; ^</P>
<P align=justify>Matrix must be square.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; a.^2</P>
<P align=justify>ans =</P>
<P align=justify>4</P>
<P align=justify>1</P>
<P align=justify>4</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; 2^a</P>
<P align=justify>??? Error using ==&gt; ^</P>
<P align=justify>Matrix must be square.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; 2.^a</P>
<P align=justify>ans =</P>
<P align=justify>4</P>
<P align=justify>2</P>
<P align=justify>4</P></FONT><B><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>Precisión utilizada</B></FONT><FONT face="Comic Sans MS" 
size=2>.- Aproximadamente 16 dígitos significativos en computadoras utilizando 
aritmética flotante IEEE. El rango aproximado es: </P>
<P align=justify>10^-308 a 10^308.</P><B>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>Formatos de salida</FONT><FONT face="Comic Sans MS" 
size=2>:</P></B>
<P align=justify>4/3</P>
<P align=justify>a) format short</P>
<P align=justify>1.3333</P>
<P align=justify>b) format short e</P>
<P align=justify>1.3333e+00</P>
<P align=justify>c) format long</P>
<P align=justify>1.33333333333333</P>
<P align=justify>d) format long e</P>
<P align=justify>1.33333333333333e00</P>
<P align=justify>e) format bank</P>
<P align=justify>1.33</P>
<P align=justify>f) format hex</P>
<P align=justify>3ff5555555555555</P></FONT><B><I><FONT face=Arial>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>5. Programando con MatLab </P></I></FONT><FONT 
face="Comic Sans MS">
<P align=justify>5.1 Generalidades</P></B></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Programar en MatLab es usar una serie de comandos que permitan 
realizar una tarea o función específica. Estos pueden ser escritos uno por uno a 
través de la línea de comandos:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;A=[1 2 3;4 5 6;7 8 9]</P>
<P align=justify>A =</P>
<P align=justify>1 2 3</P>
<P align=justify>4 5 6</P>
<P align=justify>7 8 9</P>
<P align=justify>&gt;&gt;A'</P>
<P align=justify>ans =</P>
<P align=justify>1 4 7</P>
<P align=justify>2 5 8</P>
<P align=justify>3 6 9</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>El primer comando A=[1 2 3;4 5 6;7 8 9] define la matriz A y el 
siguiente comando A' calcula y presenta en pantalla la transpuesta de 
A.</P></FONT><FONT face=Arial>
<P align=justify>&nbsp;</P>
<P align=justify>5.1.1 <U>Archivos-M: Comandos y Funciones</P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Los archivos de disco que contienen instrucciones de MATLAB se 
llaman archivos-M. Esto es así porque siempre tienen una extención de ".m" como 
la última parte de su nombre de archivo.</P>
<P align=justify>Un archivo-M consiste de una secuencia de instrucciones 
normales de MATLAB, que probablemente incluyen referencias a otros archivos-M. 
Un archivo-M se puede llamar a sí mismo recursivamente. Puedes crear archivos-M 
utilizando un editor de texto ó procesador de palabras.</P>
<P align=justify>Hay dos tipos de archivos-M: los de comandos y las funciones. 
Los archivos de comandos, automatizan secuencias largas de comandos. Los 
archivos de funciones, permiten añadir a MATLAB funciones adicionales 
expandiendo asi la capacidad de este programa. Ambos, comandos y funciones, son 
archivosordinarios de texto ASCII.</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Archivos de Comandos</P></U>
<P align=justify>Cuando un archivo de comandos es invocado, MATLAB simplemente 
ejecuta los comandos encontrados en dicho archivo. Las instrucciones en un 
archivo de comando operan globalmente en los datos en el espacio de trabajo. Los 
comandos son utilizados para hacer análisis, resolver problemas, ó diseñar 
secuencias largas de comandos que se conviertan en interactivas. Por ejemplo, 
suponga que el archivo </FONT><FONT size=2>fibo.m</FONT><FONT 
face="Comic Sans MS" size=2> contiene los siguientes comandos de MATLAB:</P>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>% Un archivo-M para calcular los elementos de la serie de 
Fibonacci </P>
<P align=justify>f = [1 1]; i = 1;</P>
<P align=justify>while f(i) + f(i+1) &lt; 1000</P>
<P align=justify>f(i+2) = f(i) + f(i+1);</P>
<P align=justify>i = i + 1;</P>
<P align=justify>end</P>
<P align=justify>plot(f)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Si escribimos </FONT><FONT size=2>fibo</FONT><FONT 
face="Comic Sans MS" size=2> en una ventana de MATLAB seguido de "enter" vemos 
que MATLAB calcula los primeros 16 números de Fibonacci, y luego grafica estos. 
Luego que la ejecución del archivo es completada, las variables f y i permanecen 
en el espacio de trabajo.</P>
<P align=justify>Los programas de demostraciones incluidos en MATLAB son 
ejemplos de como usar comandos para hacer tareas más complicadas. Para utilizar 
estos escriba demos en el "prompt" de MATLAB.</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Archivos de Funciones</P></U>
<P align=justify>Un archivo-M que contiene la palabra function al principio de 
la primera línea, es un archivo de función. En una función, a diferencia de un 
comando, se deben de pasar los argumentos. Las variables definidas y manipuladas 
dentro de la función son locales a esta y no operan globalmente en el espacio de 
trabajo. Los archivos de funciones se utilizan para extender a MATLAB, i.e., 
crear nuevas funciones para MATLAB utilizando el lenguaje propio de MATLAB.</P>
<P align=justify>El archivo </FONT><FONT size=2>mean.m</FONT><FONT 
face="Comic Sans MS" size=2> contiene las instrucciones:</P></FONT><FONT size=2>
<P align=justify>function y = mean(x)</P>
<P align=justify>% Valor medio.</P>
<P align=justify>% Para vectores, mean(x) retorna el valor medio de los 
elementos del vector x.</P>
<P align=justify>% Para matrices, mean(x) es un vector fila conteniendo el valor 
medio de cada columna.</P>
<P align=justify>[m, n] = size(x);</P>
<P align=justify>if m == 1</P>
<P align=justify>m = n;</P>
<P align=justify>end</P>
<P align=justify>y = sum(x)/m;</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>(Las lineas que comienzan con "%" son interpretadas como 
comentarios por MATLAB). La existencia de este archivo en el disco duro define 
una nueva función en MATLAB llamada </FONT><FONT size=2>mean.</FONT><FONT 
face="Comic Sans MS" size=2> Si z es un vector de los enteros desde 1 a 99, por 
ejemplo,</P></FONT><FONT size=2>
<P align=justify>z = 1:99;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>entonces, el valor promedio es encontrado escribiendo 
</P></FONT><FONT size=2>
<P align=justify>mean(z) </P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>que resultaría </P></FONT><FONT size=2>
<P align=justify>ans = </P>
<P align=justify>50</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Veamos algunos detalles de </FONT><FONT 
size=2>mean.m</FONT><FONT face="Comic Sans MS" size=2>: </P>
<P align=justify>La primera línea declara el nombre de la función, los 
argumentos de entrada, y los argumentos de salida. Sin esta línea sería un 
archivo de comando. </P>
<P align=justify>% indica que el resto de la línea es un comentario. </P>
<P align=justify>Las primeras líneas documentan el archivo-M y aparecen en la 
pantalla cuando escribimos </FONT><FONT size=2>help mean. </P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Las variables m, n, e y son locales a </FONT><FONT 
size=2>mean</FONT><FONT face="Comic Sans MS" size=2> y no existen en el espacio 
de trabajo. (O si existen, permanecen sin cambios.) </P>
<P align=justify>No es necesario asignar los enteros de 1 al 99 en la variable 
x. Utilizamos </FONT><FONT size=2>mean</FONT><FONT face="Comic Sans MS" size=2> 
con una variable llamada z.</P>
<P align=justify>Este vector que contenía los enteros de 1 a 99 fue pasado ó 
copiado a mean donde se convirtió en una variable local llamada x.</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>% Ejemplo de un archivo-m</P>
<P align=justify>% Creación del vector x usando el comando for</P>
<P align=justify>n=5;</P>
<P align=justify>for i=1:n</P>
<P align=justify>x(i)=i^2;</P>
<P align=justify>end</P>
<P align=justify>x</P>
<P align=justify>% Fin del archivo-m</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Este ejemplo es un archivo-m tipo comando. Para ejecutarlo, en 
la línea de comandos se debe escribir el nombre del archivo:</P></FONT><FONT 
size=2>
<P align=justify>&gt;&gt;ejemplo</P>
<P align=justify>x =</P>
<P align=justify>1 4 9 16 25</P></FONT><FONT face=Courier size=2>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>% Calcula el promedio de los elementos de un vector y dibuja 
dicho vector</P>
<P align=justify>% <U>Sintaxis</U>: promedio(x) donde x es el vector a 
promediar</P>
<P align=justify>function p = promedio(x)</P>
<P align=justify>n=length(x);</P>
<P align=justify>p=0;</P>
<P align=justify>for i=1:n</P>
<P align=justify>p=p+x(i);</P>
<P align=justify>end</P>
<P align=justify>p=p/n;</P>
<P align=justify>plot(x);</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Para ejecutar la función, se hace la llamada en la línea de 
comandos incluyendo el parámetro. La función promedio usa por parámetro un 
vector. Este vector debe ser definido previamente.</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;A=[1 2 4 3 7 5 6 1 2 0 8 5];</P>
<P align=justify>&gt;&gt;promedio(A)</P>
<P align=justify>ans =</P>
<P align=justify>3.6667</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>MatLab presenta las imágenes en una ventana de figuras. Al 
observar el contenido de dicha ventana luego de ejecutar la función promedio, se 
tiene: </P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify></P>
<P align=justify>Esta imagen es el resultado del comando </FONT><FONT 
size=2>plot(x)</FONT><FONT face="Comic Sans MS" size=2> al ejecutar la función 
promedio. MatLab posee un conjunto de archivos-m incorporados (built-in). Puede 
agregársele archivos-m definidos por el usuario almacenando los mismos en el 
directorio principal de MatLab. Los comentarios incluidos en estos scripts y 
funciones se visualizan al usar el comando </FONT><FONT size=2>help </FONT><FONT 
face="Comic Sans MS" size=2>seguido del nombre del archivo.</P></FONT><FONT 
size=2>
<P align=justify>&gt;&gt;help promedio</P>
<P align=justify>Calcula el promedio de los elementos de un vector y dibuja 
dicho vector</P><U>
<P align=justify>Sintaxis</U>: promedio(x) donde x es el vector a 
promediar</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Para ver el contenido de un archivo-m se usa el comando 
</FONT><FONT size=2>type</FONT><FONT face="Comic Sans MS" size=2> seguido del 
nombre del archivo.</P>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.1.2 <U>Otras funciones</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Funciones Matemáticas </P></U>
<P align=justify>Algunas funciones trigonométricas utilizadas por MATLAB 
son:</P></FONT><FONT size=2>
<P align=justify>sin</FONT><FONT face="Comic Sans MS" size=2> - 
seno</P></FONT><FONT size=2>
<P align=justify>cos</FONT><FONT face="Comic Sans MS" size=2> - 
coseno</P></FONT><FONT size=2>
<P align=justify>tan</FONT><FONT face="Comic Sans MS" size=2> - 
tangente</P></FONT><FONT size=2>
<P align=justify>asin</FONT><FONT face="Comic Sans MS" size=2> - seno 
inverso</P></FONT><FONT size=2>
<P align=justify>acos</FONT><FONT face="Comic Sans MS" size=2> - coseno 
inverso</P></FONT><FONT size=2>
<P align=justify>atan</FONT><FONT face="Comic Sans MS" size=2> - tangente 
inversa </P>
<P align=justify>&nbsp;</P>
<P align=justify>Algunas <U>funciones elementales</U> son: </P></FONT><FONT 
size=2>
<P align=justify>real(a) </FONT><FONT face="Comic Sans MS" size=2>Parte 
real</FONT><FONT size=2> </P>
<P align=justify>imag(a) </FONT><FONT face="Comic Sans MS" size=2>Parte 
imaginaria</P></FONT><FONT size=2>
<P align=justify>conj(a) </FONT><FONT face="Comic Sans MS" size=2>Conjugado de 
a</P></FONT><FONT size=2>
<P align=justify>fft(x) </FONT><FONT face="Comic Sans MS" size=2>Transformada 
discreta de Fourier del vector x</P></FONT><FONT size=2>
<P align=justify>fft(x,n) </FONT><FONT face="Comic Sans MS" size=2>FFT de n 
puntos muestrales</P></FONT><FONT size=2>
<P align=justify>ifft(x) </FONT><FONT face="Comic Sans MS" size=2>Transformada 
inversa rápida de Fourier del vector x</P></FONT><FONT size=2>
<P align=justify>ifft(x,n) </FONT><FONT face="Comic Sans MS" size=2>FFT inversa 
de n puntos muestrados</P></FONT><FONT size=2>
<P align=justify>zeros </FONT><FONT face="Comic Sans MS" size=2>Inicializa a 
ceros</P></FONT><FONT size=2>
<P align=justify>zeros(n) </FONT><FONT face="Comic Sans MS" size=2>Matriz de nxn 
de ceros</P></FONT><FONT size=2>
<P align=justify>zeros(m,n) </FONT><FONT face="Comic Sans MS" size=2>Matriz de 
mxn de ceros</P></FONT><FONT size=2>
<P align=justify>y=zeros(size(A) </FONT><FONT face="Comic Sans MS" size=2>Matriz 
del tamaño de A, todos ceros</P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>size </FONT><FONT face="Comic Sans MS" size=2>Regresa el número 
de filas y columnas</P></FONT><FONT size=2>
<P align=justify>A =</P>
<P align=justify>0 7 -6</P>
<P align=justify>1 0 0</P>
<P align=justify>0 1 0</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; [m n]=size(A)</P>
<P align=justify>m =</P>
<P align=justify>3</P>
<P align=justify>n =</P>
<P align=justify>3</P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS" size=2>
<P>Funciones matriciales</P></U></FONT><FONT size=2>
<P align=justify>tril(A)</FONT><FONT face="Comic Sans MS" size=2> Matriz 
triangular inferior</P></FONT><FONT size=2>
<P align=justify>triu(A)</FONT><FONT face="Comic Sans MS" size=2> Matriz 
triangular superior</P></FONT><FONT size=2>
<P align=justify>pascal</FONT><FONT face="Comic Sans MS" size=2> Triangulo de 
Pascal</P></FONT><FONT size=2>
<P align=justify>tocplitz</FONT><FONT face="Comic Sans MS" size=2> Tocplitz</P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplos</P></FONT><FONT size=2>
<P align=justify>&gt;&gt; A =</P>
<P align=justify>0 7 -6</P>
<P align=justify>1 0 0</P>
<P align=justify>0 1 0</P>
<P align=justify>&gt;&gt; toeplitz(A)</P>
<P align=justify>ans =</P>
<P align=justify>0 1 0 7 0 1 -6 0 0</P>
<P align=justify>1 0 1 0 7 0 1 -6 0</P>
<P align=justify>0 1 0 1 0 7 0 1 -6</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><U>
<P align=justify>Producto de dos matrices triangulares. </P></U>
<P align=justify>Esta factorización se utiliza para obtener el inverso y el 
determinante. También es la base para la solución de sistemas lineales. Para 
obtener la factorización LU de A escribimos, </P></FONT><FONT size=2>
<P align=justify>[L, U] = lu(A).</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><U>
<P align=justify>Factorización Ortogonal ó Factorización QR.</U> </P>
<P align=justify>Se utiliza para matrices cuadradas ó rectangulares. Esta 
factorización se utiliza para resolver sistemas lineales con más ecuaciones que 
desconocidas. Esta factorización también es la base para las funciones 
</FONT><FONT size=2>null</FONT><FONT face="Comic Sans MS" size=2> y </FONT><FONT 
size=2>orth</FONT><FONT face="Comic Sans MS" size=2>, que generan bases 
ortonormales para el espacio nulo y rango de una matriz rectangular dada.</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Descomposición de Valores Singulares </P></U>
<P align=justify>La descomposición de Valores Singulares es importante para el 
análisis de problemas que envuelvan matrices.</P>
<P align=justify>La asignación triple </FONT><FONT size=2>[U, S, V] = 
svd(A)</FONT><FONT face="Comic Sans MS" size=2> produce los tres factores en la 
descomposición de valores singulares A = U*S*V'. Las matrices U y V son 
ortogonales y la matriz S es diagonal. </P>
<P align=justify>La función </FONT><FONT size=2>svd(A)</FONT><FONT 
face="Comic Sans MS" size=2> devuelve solamente los elementos de la diagonal de 
S, que son los valores singulares de A.</P><U>
<P align=justify>&nbsp;</P>
<P align=justify>Descomposición de Valores Propios</P></U>
<P align=justify>La Descomposición de Valores Propios se utiliza para obtener 
los valores y vectores propios de una matriz cuadrada A. </P>
<P align=justify>La función </FONT><FONT size=2>eig(A)</FONT><FONT 
face="Comic Sans MS" size=2> devuelve los valores propios de A en un vector 
columna. </P>
<P align=justify>La asignación </FONT><FONT size=2>[X,D]=eig(A)</FONT><FONT 
face="Comic Sans MS" size=2> produce una matriz diagonal D cuyos elementos 
diagonales son los valores propios de A y las columnas de X son los vectores 
propios correspondientes.</P>
<P align=justify>&nbsp;</P>
<P align=justify>Las Funciones de norma, rango y acondicionamiento asociadas 
son:</P></FONT><FONT size=2>
<P align=justify>cond</FONT><FONT face="Comic Sans MS" size=2> - número de 
condición en la norma 2</P></FONT><FONT size=2>
<P align=justify>norm</FONT><FONT face="Comic Sans MS" size=2> - norma 1, norma 
2, norma F, norma </P></FONT><FONT size=2>
<P align=justify>rank</FONT><FONT face="Comic Sans MS" size=2> - 
rango</P></FONT><FONT size=2>
<P align=justify>rcond</FONT><FONT face="Comic Sans MS" size=2> - estimado del 
número de condición</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Funciones de Funciones </P></U>
<P align=justify>MATLAB representa funciones matemáticas mediante archivos-M de 
tipo función. Un ejemplo de una función es el archivo-M llamado </FONT><FONT 
size=2>humps.m</FONT><FONT face="Comic Sans MS" size=2>. </P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo: El archivo-M llamado </FONT><FONT 
size=2>humps.m</FONT><FONT face="Comic Sans MS" size=2> contiene las siguientes 
instrucciones:</P></FONT><FONT size=2>
<P align=justify>function y = humps(x)</P>
<P align=justify>y = 1./((x-.3).^2 +.01) + 1./((x-.9).^2 +.04) - 
6;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>y para la gráfica de la función escribimos</P></FONT><FONT 
size=2>
<P align=justify>x = -1:.01:2;</P>
<P align=justify>plot(x, humps(x))</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><U>
<P align=justify>Integración Numérica (Cuadratura)</P></U>
<P align=justify>El área bajo la gráfica de la función f(x) se puede aproximar 
integrando f(x) numéricamente mediante una regla de cuadratura. Para integrar la 
función definida por </FONT><FONT size=2>humps.m</FONT><FONT 
face="Comic Sans MS" size=2> desde 0 hasta 1 escribimos:</P></FONT><FONT size=2>
<P align=justify>q = quad('humps', 0, 1)</P>
<P align=justify>q = </P>
<P align=justify>29.8583</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Note que el argumento de </FONT><FONT size=2>quad</FONT><FONT 
face="Comic Sans MS" size=2> contiene un nombre de una función. Por esto 
</FONT><FONT size=2>quad</FONT><FONT face="Comic Sans MS" size=2> se llama una 
función de función, i.e., es una función que opera en otras funciones.</P><U>
<P align=justify>&nbsp;</P>
<P align=justify>Ecuaciones No-lineales y Funciones de Optimización</P></U>
<P align=justify>Las funciones de funciones para ecuaciones no-lineales y 
optimización incluyen:</P></FONT><FONT size=2>
<P align=justify>fmin</FONT><FONT face="Comic Sans MS" size=2> - mínimo de una 
función de una variable</P></FONT><FONT size=2>
<P align=justify>fmins</FONT><FONT face="Comic Sans MS" size=2> - mínimo de una 
función multi-variable (minimización no-lineal sin 
restricciones)</P></FONT><FONT size=2>
<P align=justify>fzero</FONT><FONT face="Comic Sans MS" size=2> - cero de una 
función de una variable</P></FONT><FONT size=2>
<P align=justify>constr</FONT><FONT face="Comic Sans MS" size=2> - minimización 
con restricciones</P></FONT><FONT size=2>
<P align=justify>fsolve</FONT><FONT face="Comic Sans MS" size=2> - solución de 
ecuación no-lineal</P></FONT><FONT size=2>
<P align=justify>leastsq</FONT><FONT face="Comic Sans MS" size=2> - cuadrados 
mínimos no-lineales</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Funciones para Ecuaciones Diferenciales</P></U>
<P align=justify>Las funciones de MATLAB para resolver problemas de valor 
inicial para ecuaciones diferenciales ordinarias son:</P></FONT><FONT size=2>
<P align=justify>ode23</FONT><FONT face="Comic Sans MS" size=2> - método 
Runge-Kutta de largo de paso variable que combina un método de orden dos con uno 
de orden tres.</P></FONT><FONT size=2>
<P align=justify>ode45</FONT><FONT face="Comic Sans MS" size=2> - método 
Runge-Kutta-Fehlberg de largo de paso variable que combina un método de orden 
cuatro con uno de orden cinco.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>to=0; tf=10;</P>
<P align=justify>[t,x]=ode23(`edif',to,tf,xo);</P>
<P align=justify>&nbsp;</P>
<P align=justify>[t,x]=ode23(`deriv',to,tf,xo);</P>
<P align=justify>ode45</P>
<P align=justify>&nbsp;</P>
<P align=justify>[t,x]=ode23(`deriv',to,tf,xo,to1,trace); </P>
<P align=justify>ode45</P>
<P align=justify>trace =&gt; 0 - no resuntados intermedios</P>
<P align=justify>1 - resultados intermedios</P>
<P align=justify>&nbsp;</P>
<P align=justify>default tol: ode23 -&gt; 1.0e-03</P>
<P align=justify>ode45 -&gt; 1.oe-06</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.1.3 <U>Declaración function</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>function nombre_1=nombre_2(parametro_1, ..., parametro_n)</P>
<P align=justify>Ejemplos:</P>
<P align=justify>function y=promedio(x)</P>
<P align=justify>function i=inodal(t,v)</P>
<P align=justify>function xpunto=vdpol(t,x)</P>
<P align=justify>xpunto=zeros(2,1);</P>
<P align=justify>xpunto(1)=x(1).*(1-x(2).^2)-x(2);</P>
<P align=justify>xpunto(2)=x(1);</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>5.2 Operadores relacionales </P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Los operadores relacionales de MatLab son:</P>
<P align=justify>&lt; menor que </P>
<P align=justify>&lt;= menor o igual a </P>
<P align=justify>&gt; mayor que </P>
<P align=justify>&gt;= mayor o igual a </P>
<P align=justify>== igual a </P>
<P align=justify>=~ no igual a </P><B>
<P align=justify>Ejemplo:</P></B></FONT><FONT size=2>
<P align=justify>if n&lt; maxn</P>
<P align=justify>...</P>
<P align=justify>if n&gt;=0, break, end</P></FONT><FONT face=Arial>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>5.3 Operadores lógicos </P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Los operadores &amp;, | y ~ son los operadores de lógica "y", 
"ó" y "no" respectivamente.</P>
<P align=justify>El resultado de C = A &amp; B es una matriz cuyos elementos son 
unos donde A y B sean ambos distintos de cero, y ceros donde A ó B sean cero. A 
y B deben de ser matrices con las mismas dimensiones, a menos que una de ellas 
sea un escalar.</P>
<P align=justify>El resultado de C = A | B es una matriz cuyos elementos son 
unos donde A ó B tienen un elemento diferentede cero, y ceros donde ambas tienen 
elementos cero. A y B deben de ser matrices con las mismas dimensiones, a menos 
que una sea un escalar.</P>
<P align=justify>El resultado de B = ~A es una matriz cuyos elementos son uno 
donde A tiene un elemento cero, y ceros donde A tiene elementos diferentes de 
cero.</P><U>
<P align=justify>&nbsp;</P>
<P align=justify>Funciónes</U> </FONT><B><FONT size=2>any, 
all</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>La función </FONT><FONT size=2>any(x)</FONT><FONT 
face="Comic Sans MS" size=2> devuelve 1 si cualquiera de los elementos de x es 
diferente de cero, de lo contrario devuelve 0. </P>
<P align=justify>La función </FONT><FONT size=2>all(x)</FONT><FONT 
face="Comic Sans MS" size=2> devuelve 1 solamente si todos los elementos de x 
son diferentes de cero.</P>
<P align=justify>Estas funciones se usan en cláusulas </FONT><FONT 
size=2>if</FONT><FONT face="Comic Sans MS" size=2>. Por ejemplo: 
</P></FONT><FONT size=2>
<P align=justify>if all(A &lt;.5) </P>
<P align=justify>. . . </P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Para argumentos matriciales, </FONT><FONT 
size=2>any</FONT><FONT face="Comic Sans MS" size=2> y </FONT><FONT 
size=2>all</FONT><FONT face="Comic Sans MS" size=2> trabajan por columnas para 
devolver un vector fila con el resultado para cada columna. Aplicando la función 
dos veces, </FONT><FONT size=2>any(any(A)),</FONT><FONT face="Comic Sans MS" 
size=2> siempre reduce la matriz a una condición escalar.</P>
<P align=justify>Las funciones relacionales y lógicas en MATLAB 
son:</P></FONT><FONT size=2>
<P align=justify>any</FONT><FONT face="Comic Sans MS" size=2> - condiciones 
lógicas</P></FONT><FONT size=2>
<P align=justify>all</FONT><FONT face="Comic Sans MS" size=2> - condiciones 
lógicas</P></FONT><FONT size=2>
<P align=justify>find</FONT><FONT face="Comic Sans MS" size=2> - halla índices 
de arreglos de valores lógicos</P></FONT><FONT size=2>
<P align=justify>exist</FONT><FONT face="Comic Sans MS" size=2> - verifica si 
existen variables</P></FONT><FONT size=2>
<P align=justify>isinf</FONT><FONT face="Comic Sans MS" size=2> - detecta 
infinitos</P></FONT><FONT size=2>
<P align=justify>finite</FONT><FONT face="Comic Sans MS" size=2> - verifica para 
los valores finitos</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>5.4 Caracteres especiales</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Los caracteres especiales de MatLab son:</P>
<P align=justify>[ ] Se utilizan para formar vectores y matrices </P>
<P align=justify>( ) Define precedencia en expresiones aritméticas. Encierra 
argumentos de funciones en forma usual </P>
<P align=justify>, Separador de elementos de una matriz, argumentos de funciones 
y declaraciones en líneas con declaraciones múltiples </P>
<P align=justify>; Termina filas de una matriz, separador de declaraciones </P>
<P align=justify>% Comentario </P>
<P align=justify>&nbsp;</P><B>
<P align=justify>Ejemplos:</P></B></FONT><FONT size=2>
<P align=justify>[6.0 9.0 3.4 ]</P>
<P align=justify>sqrt(2)</P>
<P align=justify>for i=1:n, a(i)=0, end</P>
<P align=justify>for i=1:n; a(i)=0; end</P>
<P align=justify>% inicia vector a en 0</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>5.5 Contro</B>l<B> de flujo </P></B></FONT><FONT face=Arial>
<P align=justify>5.5.1 <U>Declaración FOR simple</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>for variable=incio:paso:final</P>
<P align=justify>declaración 1;</P>
<P align=justify>...</P>
<P align=justify>declaración n;</P>
<P align=justify>end</P>
<P align=justify>&nbsp;</P>
<P align=justify>for variable=inicio:final</P>
<P align=justify>declaración 1;</P>
<P align=justify>...</P>
<P align=justify>declaración n;</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><B>
<P align=justify>Ejemplo:</P></B></FONT><FONT size=2>
<P align=justify>for i=1:n</P>
<P align=justify>c(i)=a(i)*b(i);</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>o</P></FONT><FONT size=2>
<P align=justify>for i=1:n; c(i)=a(i)*b(i); end</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>El ciclo FOR permite que una instrucción, ó grupo de 
instrucciones, pueda repetirse un número determinado de veces. Por ejemplo, 
</P></FONT><FONT size=2>
<P align=justify>for i = 1:n, x(i) = 0, end </P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>asigna 0 a los primeros n elementos de x. Si n es menor de 1, 
el ciclo sigue siendo válido pero MATLAB no ejecuta la instrucción intermedia. 
Si x no esta definido, ó si tiene menos de n elementos, entonces un espacio 
adicional es localizado automáticamente a x cada vez que sea necesario. </P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>&nbsp;</P>
<P align=justify>5.5.2 <U>Declaración FOR anidada</U>.</P></FONT><U><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>for variable 1 = inicio1:paso1:fin1</P>
<P align=justify>for variable2 = inicio2:paso2:fin2</P>
<P align=justify>declaración 1;</P>
<P align=justify>...</P>
<P align=justify>declaración n;</P>
<P align=justify>end</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><B>
<P align=justify>Ejemplo</P></B></FONT><FONT size=2>
<P align=justify>y=1</P>
<P align=justify>for t1=0:0.1:1</P>
<P align=justify>for t2=1:-0.1:0</P>
<P align=justify>y(1)=sin(t1*t2)</P>
<P align=justify>end</P>
<P align=justify>i=i+1;</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>for i = 1:m</P>
<P align=justify>for j = 1:n</P>
<P align=justify>A(i, j) = 1/(i+j-1);</P>
<P align=justify>end</P>
<P align=justify>end</P>
<P align=justify>A</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>La "A" al terminar el ciclo muestra en la pantalla el resultado 
final. Es importante que para cada for halla un end.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.5.3 <U>Declaración WHILE</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Sintaxis:</P></U></FONT><FONT face=Arial size=2>
<P align=justify>while expresion</P>
<P align=justify>proposición 1;</P>
<P align=justify>...</P>
<P align=justify>proposición 2;</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><B>
<P align=justify>Ejemplos</P></B></FONT><FONT size=2>
<P align=justify>e=1.0;</P>
<P align=justify>while (1.0+e)&gt;1.0001</P>
<P align=justify>e=e/2.0;</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>it=1; t=0; wo=2.0*pi*60.0;</P>
<P align=justify>while it&lt;=npts, ut=sin(wo*t);t=t+dt;end</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>El ciclo WHILE permite a una instrucción, ó grupo de 
instrucciones, repetirse un número indefinido de veces, bajo el control de una 
condición lógica. El siguiente ciclo while halla el primer entero n para el cual 
n! es un número de 100 digitos:</P></FONT><FONT size=2>
<P align=justify>&nbsp;</P>
<P align=justify>n = 1;</P>
<P align=justify>while prod(1:n) &lt; 1.0e100, n = n+1; end</P>
<P align=justify>n</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Un cálculo más práctico ilustrando el ciclo while es en el 
cómputo del exponencial de una matriz, llamado </FONT><FONT 
size=2>expm(A)</FONT><FONT face="Comic Sans MS" size=2> en MATLAB. Una posible 
definición de la función exponencial es mediante la serie:</P>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>expm(A) = I + A + A^2/2! + A^3/3! + ...</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>La idea es sumar todos los términos necesarios hasta producir 
un resultado que, en la precisión finita la de computadora, no cambie aunque más 
términos sean añadidos. Para esto procedemos de la forma siguiente: </P>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>E = zeros(size(A));</P>
<P align=justify>F = eye(size(A));</P>
<P align=justify>k = 1;</P>
<P align=justify>while norm(E+F-E, 1) &gt; 0</P>
<P align=justify>E = E + F;</P>
<P align=justify>F = A*F/k</P>
<P align=justify>k = k+1;</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Aqui A es la matriz dada, E representa la suma parcial de la 
serie, F es un término individual en la serie, y k es el índice de este 
término.</P>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.5.4 <U>Declaraciones IF, ELSE, ELSEIF y BREAK</U> 
</P></FONT><U><FONT face="Comic Sans MS" size=2>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>a) if expresión</P>
<P align=justify>proposición 1;</P>
<P align=justify>...</P>
<P align=justify>proposición n;</P>
<P align=justify>end</P>
<P align=justify>&nbsp;</P>
<P align=justify>b) if expresión</P>
<P align=justify>proposición 1;</P>
<P align=justify>...</P>
<P align=justify>proposición n;</P>
<P align=justify>else</P>
<P align=justify>proposición 1;</P>
<P align=justify>...</P>
<P align=justify>proposición m;</P>
<P align=justify>end</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>c) if expresión</P>
<P align=justify>proposición 1;</P>
<P align=justify>...</P>
<P align=justify>proposición n;</P>
<P align=justify>elseif</P>
<P align=justify>proposición 1;</P>
<P align=justify>...</P>
<P align=justify>proposición m;</P>
<P align=justify>else</P>
<P align=justify>proposición 1;</P>
<P align=justify>...</P>
<P align=justify>proposición r;</P>
<P align=justify>end</P>
<P align=justify>&nbsp;</P>
<P align=justify>d) if expresión, break, end</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><B>
<P align=justify>Ejemplos</P></B></FONT><FONT size=2>
<P align=justify>if dv(i) &gt; maxer</P>
<P align=justify>maxer=dv(i);</P>
<P align=justify>nmaxe=i;</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>sum=0.0; y=1;</P>
<P align=justify>while i&lt;=so</P>
<P align=justify>n=input(`Introduzca n, interrumpe con valor negativo `);</P>
<P align=justify>if n&lt;0, break, end;</P>
<P align=justify>if n==0</P>
<P align=justify>sum=sum+n;</P>
<P align=justify>elseif n&lt;=10</P>
<P align=justify>sum=sum+n/2;</P>
<P align=justify>else</P>
<P align=justify>sum=sum+n/10;</P>
<P align=justify>end</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>A continuación se muestra como un cálculo se puede dividir en 
tres casos, dependiendo del signo ó paridad de un entero n:</P>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>if n &lt; 0</P>
<P align=justify>A = negative(n)</P>
<P align=justify>else if rem(n, 2) == 0</P>
<P align=justify>A = even(n)</P>
<P align=justify>else</P>
<P align=justify>A = odd(n)</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>En el segundo, partiendo de un entero positivo n, si este es 
par, se divide entre dos; si es impar, se multiplica por tres y se le suma uno. 
¿Habrá algún entero para el cual el proceso nunca termine? Aquí se ilustran los 
enunciados </FONT><FONT size=2>while</FONT><FONT face="Comic Sans MS" size=2> y 
</FONT><FONT size=2>if</FONT><FONT face="Comic Sans MS" size=2>, también se 
muestra la función input (en este caso es una entrada del teclado), y el 
enunciado </FONT><FONT size=2>break</FONT><FONT face="Comic Sans MS" size=2>, 
que provee salidas abruptas de los ciclos. Veamos:</P>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>% Problema "3n+1" clásico de la teoria de números.</P>
<P align=justify>while 1</P>
<P align=justify>n = input('Entre n, negativo termina. ');</P>
<P align=justify>if n &lt;= 0, break, end</P>
<P align=justify>while n &gt; 1</P>
<P align=justify>if rem(n, 2) == 0</P>
<P align=justify>n = n/2</P>
<P align=justify>else</P>
<P align=justify>n = 3*n+1</P>
<P align=justify>end</P>
<P align=justify>end</P>
<P align=justify>end</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>5.6 Algebra Matricial </P></B></FONT><FONT face=Arial>
<P align=justify>5.6.1 <U>Creación de una matriz</P></U></FONT><B><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P></B></FONT><FONT size=2>
<P align=justify>&gt;&gt; A=[1 2 3; 4 5 6; 7 8 9]</P>
<P align=justify>A =</P>
<P align=justify>1 2 3</P>
<P align=justify>4 5 6</P>
<P align=justify>7 8 9</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.6.2 <U>Cambio del orden de una matriz: 
</FONT><B>reshape</P></B><FONT face="Comic Sans MS" size=2>
<P align=justify>Sintaxis:</P></U>
<P align=justify></FONT><FONT face=Arial size=2>matriz_modificada = 
reshape(matriz_original, filas, columnas)</P></FONT><B><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P></B></FONT><FONT size=2>
<P align=justify>&gt;&gt; A=[1 4 7 10; 2 5 8 11; 3 6 9 12]</P>
<P align=justify>A =</P>
<P align=justify>1 4 7 10</P>
<P align=justify>2 5 8 11</P>
<P align=justify>3 6 9 12</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>&gt;&gt; B=reshape(A,2,6)</P>
<P align=justify>B =</P>
<P align=justify>1 3 5 7 9 11</P>
<P align=justify>2 4 6 8 10 12</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.6.3 <U>Modificación individual de 
elementos</P></U></FONT><B><FONT face="Comic Sans MS" size=2>
<P align=justify>Ejemplos</P></B></FONT><FONT size=2>
<P align=justify>&gt;&gt; A=[1 2; 3 4]</P>
<P align=justify>A =</P>
<P align=justify>1 2</P>
<P align=justify>3 4</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; A(1,1)=A(1,2)+A(2,1)</P>
<P align=justify>A =</P>
<P align=justify>5 2</P>
<P align=justify>3 4</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; A(1,2)=A(2,1)</P>
<P align=justify>A =</P>
<P align=justify>5 3</P>
<P align=justify>3 4</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; A(2,2)=10</P>
<P align=justify>A =</P>
<P align=justify>5 3</P>
<P align=justify>3 10</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.6.4 <U>Modificaciones adicionales de una 
matriz</P></U></FONT><B><FONT face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P></B></FONT><FONT size=2>
<P align=justify>&gt;&gt; A=[1 2; 3 4; 5 6 ]</P>
<P align=justify>A =</P>
<P align=justify>1 2</P>
<P align=justify>3 4</P>
<P align=justify>5 6</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><U>
<P>Conversión de una matriz en un vector</P></U>
<P>&nbsp;</P></FONT><FONT size=2>
<P align=justify>&gt;&gt; A=[1 2; 3 4; 5 6 ]</P>
<P align=justify>A =</P>
<P align=justify>1 2</P>
<P align=justify>3 4</P>
<P align=justify>5 6</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; b=A(:)</P>
<P align=justify>b =</P>
<P align=justify>1</P>
<P align=justify>3</P>
<P align=justify>5</P>
<P align=justify>2</P>
<P align=justify>4</P>
<P align=justify>6</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><U>
<P align=justify>&nbsp;</P>
<P align=justify>Modificación de los elementos</P></U></FONT><FONT size=2>
<P align=justify>&gt;&gt; A(:)=10:15</P>
<P align=justify>A =</P>
<P align=justify>10 13</P>
<P align=justify>11 14</P>
<P align=justify>12 15</P></FONT><U><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Generación de vectores</U><B>:</P>
<P align=justify>Ejemplos</P></B></FONT><FONT size=2>
<P align=justify>&gt;&gt; x=1:5</P>
<P align=justify>x =</P>
<P align=justify>1 2 3 4 5</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; x=5:-1:1</P>
<P align=justify>x =</P>
<P align=justify>5 4 3 2 1</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; x=0:0.25:1</P>
<P align=justify>x =</P>
<P align=justify>0 0.2500 0.5000 0.7500 1.0000</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><U>
<P align=justify>Acceso a submatrices contiguas y no contiguas</P></U><B>
<P align=justify>Ejemplos</P></B>
<P align=justify>Si la matriz original A es de 10*10, entonces: </P>
<P align=justify>A(1:3,5) matriz de 3x1 que tiene los tres primeros elementos de 
la columna 5 de A </P>
<P align=justify>A(1:3, 5:9) matriz de 3x4 que tiene los tres primeros filas y 
las columnas de 5 a 9 de A </P>
<P align=justify>A(:,5) quinta columna de A </P>
<P align=justify>A(1:5,:) primeras cinco filas de A </P>
<P align=justify>A(:,[4 6])=B(:,1:2) remplaza la cuarta y sexta columnas de A 
con las dos primeras de A </P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>&nbsp;</P>
<P align=justify>Matrices vacias</P></U>
<P align=justify>La declaración </P>
<P align=justify>x = [ ] </P>
<P align=justify>asigna una matriz de dimensión 0x0 a x</P>
<P align=justify>&nbsp;</P>
<P align=justify>Para la matriz A considerada previamente</P>
<P align=justify>A(:,[3,5])=[ ] borra columnas 3 y 5 de A</P>
<P align=justify>A([3,5 ],:)=[ ] borra filas 3 y 5 de A</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Declaración de matrices complejas</P></U>
<P align=justify>A=[1 2; 3 4] + i*[5 6 ; 7 8]</P>
<P align=justify>o</P>
<P align=justify>A=[1 2; 3 4] + i*[5 6 ; 7 8]</P>
<P align=justify>o</P>
<P align=justify>A=[1+5i 2+6i; 3+7i 4+8i]</P>
<P align=justify>A =</P>
<P align=justify>1.0000 + 5.0000i 2.0000 + 6.0000i</P>
<P align=justify>3.0000 + 7.0000i 4.0000 + 8.0000i</P></FONT><FONT face=Arial>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS" size=2>
<P>Generación de tablas</P></U></FONT><FONT size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; x=(0.0:0.2:3.0);</P>
<P align=justify>&gt;&gt; y=exp(-x).*sin(x);</P>
<P align=justify>&gt;&gt; [x;y]</P>
<P align=justify>ans =</P>
<P align=justify>Columns 1 through 7 </P>
<P align=justify>0 0.2000 0.4000 0.6000 0.8000 1.0000 1.2000</P>
<P align=justify>0 0.1627 0.2610 0.3099 0.3223 0.3096 0.2807</P>
<P align=justify>Columns 8 through 14 </P>
<P align=justify>1.4000 1.6000 1.8000 2.0000 2.2000 2.4000 2.6000</P>
<P align=justify>0.2430 0.2018 0.1610 0.1231 0.0896 0.0613 0.0383</P>
<P align=justify>Columns 15 through 16 </P>
<P align=justify>2.8000 3.0000</P>
<P align=justify>0.0204 0.0070</P></FONT><U><FONT face="Comic Sans MS" size=2>
<P align=justify>Determinante de A</U>:<U> </U></FONT><B><FONT 
size=2>det(A)</P></B>
<P align=justify>&gt;&gt; A=[1 2 3;4 5 6; 7 8 9]</P>
<P align=justify>A =</P>
<P align=justify>1 2 3</P>
<P align=justify>4 5 6</P>
<P align=justify>7 8 9</P>
<P align=justify>&gt;&gt; det(A)</P>
<P align=justify>ans =0</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><U>
<P align=justify>Diagonal de A</U><B>: </FONT><FONT size=2>diag(A)</P></B>
<P align=justify>&gt;&gt; diag(A)</P>
<P align=justify>ans =</P>
<P align=justify>1</P>
<P align=justify>5</P>
<P align=justify>9</P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS" size=2>
<P align=justify>Valores y vectores característicos</U><B>: </FONT><FONT 
size=2>eig(A)</P></B>
<P align=justify>&gt;&gt; A=[0 7 -6; 1 0 0;0 1 0]</P>
<P align=justify>A =</P>
<P align=justify>0 7 -6</P>
<P align=justify>1 0 0</P>
<P align=justify>0 1 0</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; eig(A)</P>
<P align=justify>ans =</P>
<P align=justify>-3.0000</P>
<P align=justify>2.0000</P>
<P align=justify>1.0000</P>
<P align=justify>&nbsp;</P>
<P align=justify>v - Vectores característicos </P>
<P align=justify>d - valores característicos </P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; [v d]=eig(A)</P>
<P align=justify>v =</P>
<P align=justify>0.9435 -0.8729 0.5774</P>
<P align=justify>-0.3145 -0.4364 0.5774</P>
<P align=justify>0.1048 -0.2182 0.5774</P>
<P align=justify>d =</P>
<P align=justify>-3.0000 0 0</P>
<P align=justify>0 2.0000 0</P>
<P align=justify>0 0 1.0000</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>- <U>Exponencial de una matriz</U><B>: </FONT><FONT 
size=2>expm(A)</P></B>
<P align=justify>&gt;&gt; A=[0 7 -6; 1 0 0;0 1 0]</P>
<P align=justify>A =</P>
<P align=justify>0 7 -6</P>
<P align=justify>1 0 0</P>
<P align=justify>0 1 0</P>
<P align=justify>&nbsp;</P>
<P align=justify>&gt;&gt; expm(A)</P>
<P align=justify>ans =</P>
<P align=justify>5.2541 11.0757 -13.6115</P>
<P align=justify>2.2686 5.2541 -4.8044</P>
<P align=justify>0.8007 2.2686 -0.3510</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>- <U>Factorización LU de A</U>: </FONT><B><FONT 
size=2>lu(A)</P></B>
<P align=justify>&gt;&gt; [L U]=lu(A)</P>
<P align=justify>L =</P>
<P align=justify>0 1.0000 0</P>
<P align=justify>1.0000 0 0</P>
<P align=justify>0 0.1429 1.0000</P>
<P align=justify>U =</P>
<P align=justify>1.0000 0 0</P>
<P align=justify>0 7.0000 -6.0000</P>
<P align=justify>0 0 0.8571</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>- <U>Inversa de A</U>: </FONT><B><FONT size=2>inv(A)</P></B>
<P align=justify>&gt;&gt; inv(A)</P>
<P align=justify>ans =</P>
<P align=justify>0 1.0000 0</P>
<P align=justify>0 0 1.0000</P>
<P align=justify>-0.1667 0 1.1667</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>- <U>Ecuación característica de la matriz A</U>: 
</FONT><B><FONT size=2>poly(A)</P></B>
<P align=justify>&gt;&gt; p=poly(A)</P>
<P align=justify>p =</P>
<P align=justify>1.0000 0.0000 -7.0000 6.0000 </P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>- <U>Raices de la ecuación característica</U></FONT><FONT 
size=2>: <B>roots(p)</P></B>
<P align=justify>&gt;&gt; r=roots(p)</P>
<P align=justify>r =</P>
<P align=justify>-3.0000</P>
<P align=justify>2.0000</P>
<P align=justify>1.0000</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>5.7 Archivos de E/S </P></B></FONT><FONT face=Arial>
<P align=justify>5.7.1 <U>Declaración </FONT><B>fopen</P></B><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>id = fopen(`nombre.dat', `permiso')</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>donde </FONT><FONT face=Arial size=2>permiso</FONT><FONT 
face="Comic Sans MS" size=2> puede ser: </P></FONT><FONT face=Arial size=2>
<P align=justify>`r' Abre archivo para lectura </P>
<P align=justify>`r+ Abre archivo para lectura y escritura </P>
<P align=justify>`w' Borra el contenido del archivo existente o crea un nuevo 
archivo y lo abre para escritura </P>
<P align=justify>`w+' Idem que `w' únicamente que el archivo se abre para 
lectura y escritura </P>
<P align=justify>`a' Crea y abre un nuevo archivo o abre un archivo </P>
<P align=justify>`a+' Idem</FONT><FONT face="Comic Sans MS" size=2> que `a' 
únicamente que el archivo es abierto para lectura y escritura </P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>fid = fopen(`archivo.dat','r')</P>
<P align=justify>fid = -1, error</P>
<P align=justify>0, lectura/escritura normal</P>
<P align=justify>[fid, mensaje = fopen(`archivo.dat','r')</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.7.2 <U>Declaración </FONT><B>fclose</P></B><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>status = fclose(fid)</P>
<P align=justify>o</P>
<P align=justify>status = fclose (`all') - cierra todos los archivos 
abiertos</P>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.7.3 <U>Declaración </FONT><B>fread</P></B></U><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Lee un archivo abierto con una precisión indicada</P><U>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>fread(fid,registros,'precision')</P>
<P align=justify>registros</P>
<P align=justify>`char' o `uchar'</P>
<P align=justify>`short' o `long'</P>
<P align=justify>`float' o `double'</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><B>
<P align=justify>Ejemplo:</P></B></FONT><FONT size=2>
<P align=justify>A = fread(fid,10,'float'</FONT><FONT face="Comic Sans MS" 
size=2>)</P>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.7.4 <U>Declaración </FONT><B>fwrite</P></B><FONT 
face="Comic Sans MS">
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>fwrite(fid,A,'short')</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.7.5 <U>Declaración <B>fprintf</P></B></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Salida con formato</P><B>
<P align=justify>Ejemplos:</P></B></FONT><FONT size=2>
<P align=justify>fprintf(fid,'titulo\n');</P>
<P align=justify>fprintf(fid,'%f %12.7f\n', y);</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Formato</P>
<P align=justify>%s - cadena decimal</P>
<P align=justify>%d - número decimal</P>
<P align=justify>%f - punto flotante</P>
<P align=justify>% g - formato g</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>5.8 Variables globales </P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Son variables, de las cuales una sola copia es compartida por 
el programa principal y sus funciones.</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>global variable1, ..., variable_N</P></FONT><B><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></B></FONT><FONT size=2>
<P align=justify>function x=ccdifs(t,x)</P>
<P align=justify>global ka,kb</P>
<P align=justify>xp=[x(1)-ka*x(1)*x(2); -x(2)+kb*x(1)*x(2)];</P>
<P align=justify>...</P>
<P align=justify>global ka,kb</P>
<P align=justify>ka=0.01</P>
<P align=justify>kb=0.02</P>
<P align=justify>[t,x]=ode23('ccdifs',0,10,[1:1]);</P></FONT><B><FONT 
face="Comic Sans MS">
<P align=justify>5.9 Vectorización de algoritmos y estructuras (for, 
while)</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Para que los programas en MATLAB ejecuten más rápido, debemos 
vectorizar estos siempre que sea posible. Esto es, debemos convertir los ciclos 
for y while a operaciones de vectores ó de matrices. Por ejemplo, un modo de 
calcular la función "sin" para 1001 números entre 1 y 10 es:</P></FONT><FONT 
size=2>
<P align=justify>i = 0;</P>
<P align=justify>for t = 0:.01:10</P>
<P align=justify>i = i + 1;</P>
<P align=justify>y(i) = sin(t);</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Una versión vectorizada del mismo código es</P></FONT><FONT 
size=2>
<P align=justify>t = 0:.01:10; y = sin(t);</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>En una computadora lenta, el primer ejemplo tomó 15 segundos, 
mientras que el segundo tomó 0.6 segundos.</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Vectores Pre-Asignados</P></U>
<P align=justify>Si no podemos vectorizar un pedazo de código, podemos hacer que 
los ciclos for vayan más rápido pre-asignando cualquier vector en el cual el 
resultado de salida sea guardado. Veamos un ejemplo:</P></FONT><FONT size=2>
<P align=justify>y = zeros (1,100);</P>
<P align=justify>for i = 1:100</P>
<P align=justify>y(i) = det(X^i);</P>
<P align=justify>end</P></FONT><FONT face="Comic Sans MS" size=2>
<P>Si no pre-asignamos el vector "y", el interpretador de MATLAB irá aumentando 
el tamaño de "y" por uno cada vez que se itera en el ciclo.</P>
<P align=justify>Permite incrementar la velocidad de proceso de MATLAB</P><U>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>variable=inicio:incremento:final</P></FONT><B><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P></B></FONT><FONT size=2>
<P align=justify>i=1, wo=2*pi*fo;</P>
<P align=justify>for t=0:dt:per</P>
<P align=justify>f(i)=sin(wo*t);</P>
<P align=justify>i=i+1;</P>
<P align=justify>end</P>
<P align=justify>ó</P>
<P align=justify>t=0:dt:per;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>fi=sin(wo*t);</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>5.10 Gráficas en Dos Dimensiones</P></B>
<P align=justify>5.10.1 <U>Funciones elementales para graficar 
</P></U></FONT><B><FONT size=2>
<P align=justify>plot</B></FONT><FONT face="Comic Sans MS" size=2> - crea una 
gráfica de vectores ó columnas de matrices. </P></FONT><B><FONT size=2>
<P align=justify>loglog</B></FONT><FONT face="Comic Sans MS" size=2> - crea una 
gráfica utilizando una escala logarítmica para ambos ejes.</P></FONT><B><FONT 
size=2>
<P align=justify>semilogx</B></FONT><FONT face="Comic Sans MS" size=2> - crea 
una gráfica utilizando una escala logarítmica para el eje-x y una escala lineal 
para el eje-y. </P></FONT><B><FONT size=2>
<P align=justify>semilogy</B></FONT><FONT face="Comic Sans MS" size=2> - crea 
una gráfica utilizando una escala logarítmica para el eje-y y una escala lineal 
para el eje-x. </P>
<P align=justify>Puedes añadir títulos, encabezamientos de ejes, líneas entre 
cortadas y texto a tus gráficas utilizando:</P></FONT><B><FONT size=2>
<P align=justify>tittle</B></FONT><FONT face="Comic Sans MS" size=2> - añade 
título a la gráfica</P></FONT><B><FONT size=2>
<P align=justify>xlabel</B></FONT><FONT face="Comic Sans MS" size=2> - añade 
encabezamiento al eje-x</P></FONT><B><FONT size=2>
<P align=justify>ylabel</B></FONT><FONT face="Comic Sans MS" size=2> - añade 
encabezamiento al eje-y</P></FONT><B><FONT size=2>
<P align=justify>text</B></FONT><FONT face="Comic Sans MS" size=2> - añade una 
cadena de texto en una localización específica</P></FONT><B><FONT size=2>
<P align=justify>gtext</B></FONT><FONT face="Comic Sans MS" size=2> - añade 
texto a la gráfica utilizando el ratón</P></FONT><B><FONT size=2>
<P align=justify>grid</B></FONT><FONT face="Comic Sans MS" size=2> - crea líneas 
entrecortadas</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>5.10.2 <U>Creando una gráfica</P></U></FONT><B><FONT 
face="Comic Sans MS" size=3>
<P>Comando</FONT><FONT face="Comic Sans MS" size=5> </FONT><FONT 
size=5>Plot</P></B></FONT><U><FONT face="Comic Sans MS" size=2>
<P align=justify>Sintaxis:</P></U></FONT><FONT face=Arial size=2>
<P align=justify>a) plot(y)</P>
<P align=justify>b) plot(x,y)</P>
<P align=justify>c) plot(x,y,'tipo_línea')</P>
<P align=justify>d) plot(x1,y1,'tipo_línea_1',x2,y2,'tipo_línea_2', ... , 
xn,yn,'tipo_línea_n')</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Si </FONT><FONT size=2>y</FONT><FONT face="Comic Sans MS" 
size=2> es un vector, </FONT><FONT size=2>plot(y)</FONT><FONT 
face="Comic Sans MS" size=2> produce una gráfica lineal de los elementos de y 
versus el índice de estos. Si especifica dos vectores como argumentos, 
</FONT><FONT size=2>plot(x, y)</FONT><FONT face="Comic Sans MS" size=2> produce 
una gráfica de </FONT><FONT size=2>y </FONT><FONT face="Comic Sans MS" 
size=2>versus </FONT><FONT size=2>x</FONT><FONT face="Comic Sans MS" 
size=2>.</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Símbolo Color </P></U></FONT><FONT face=Arial size=2>
<P align=justify>y amarillo </P>
<P align=justify>m magenta</P>
<P align=justify>c cyan (azul claro)</P>
<P align=justify>r rojo</P>
<P align=justify>g verde</P>
<P align=justify>b azul</P>
<P align=justify>w blanco</P>
<P align=justify>k negro</P>
<P align=justify>&nbsp;</P></FONT><U><FONT face="Comic Sans MS" size=2>
<P align=justify>Símbolo Estilo de línea</P></U></FONT><FONT face=Arial size=2>
<P align=justify>. punto</P>
<P align=justify>o circulo</P>
<P align=justify>x marca</P>
<P align=justify>+ mas</P>
<P align=justify>* asterisco</P>
<P align=justify>- sólido</P>
<P align=justify>: punteado</P>
<P align=justify>-. segmento punto</P>
<P align=justify>-- segmento</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=3>
<P align=justify>t=0:pi/200:2*pi;x=sin(t);y1=sin(t+0.5);y2=sin(t+1.0);</P>
<P align=justify>plot(x,y1,'r-',x,y2,'g--'); title('Angulo difuso'); 
xlabel('x=sin(t)'); ...</P>
<P align=justify>ylabel('y=sin(t+)')</P></FONT><FONT size=2>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>5.10.3 <U>Graficando Matrices</P></U></FONT><B><FONT size=2>
<P align=justify>plot(Y)</FONT><FONT face="Comic Sans MS" size=2>-</B> dibuja 
una línea para cada columna de Y. El eje-x es encabezado por el vector índice de 
fila, 1:m, donde m es el número de filas en Y.</P>
<P align=justify>Si </FONT><FONT size=2>plot</FONT><FONT face="Comic Sans MS" 
size=2> es usado con dos argumentos y si X ó Y tienen más de una fila ó columna, 
entonces: </P>
<P align=justify>si Y es una matriz, y x es un vector, plot(x,Y) grafica las 
filas ó columnas de Y versus el vector x; </P>
<P align=justify>si X es una matriz y y es un vector, plot(X,y) grafica cada 
fila ó columna de X versus el vector y; </P>
<P align=justify>si X y Y son ambas matrices del mismo tamaño, plot(X, Y) 
grafica las columnas de X versus las columnas de Y.</P>
<P align=justify>&nbsp;</P>
<P align=justify>También puedes usar la función </FONT><FONT 
size=2>plot</FONT><FONT face="Comic Sans MS" size=2> con múltiples pares de 
argumentos matriciales:</P></FONT><FONT size=2>
<P align=justify>plot (X1, Y1, X2, Y2, ...)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Cada par X-Y es graficado, generando líneas múltiples. Los 
pares diferentes pueden ser de dimensiones diferentes.</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>5.10.4 <U>Importando Datos</P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Puede importar y graficar datos generados fuera de MATLAB 
utilizando el comando </FONT><FONT size=2>load</FONT><FONT face="Comic Sans MS" 
size=2>.</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS">
<P align=justify>5.10.5 <U>Graficando Funciones Matemáticas </P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Hay diferentes formas de graficar funciones y = f(x). Una de 
estas formas es evaluar la función en miles de puntos en el intervalo de 
interés. La siguiente función oscila infinitamente rápido en el intervalo, 0 x 
1.</P>
<P align=justify>Podemos gráficarla como sigue:</P></FONT><FONT size=2>
<P align=justify>x = (0:1/2000:1)';</P>
<P align=justify>plot(x, cos(tan(pi*x))) </P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Para hacer esto más eficiente podemos usar la función 
</FONT><FONT size=2>fplot</FONT><FONT face="Comic Sans MS" size=2> la cual 
concentra su evaluación sobre las regiones donde la rapidez de cambio de la 
función es más grande. </P>
<P align=justify>&nbsp;</P>
<P align=justify>Para evaluar una función, se crea un archivo de esta función y 
se le pasa el nombre del archivo a fplot. El siguiente archivo-M de tipo función 
define la función anterior como fofx. </P></FONT><FONT size=2>
<P align=justify>function y = fofx(x)</P>
<P align=justify>y = cos(tan(pi*x)); </P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Este archivo se guarda con el nombre de </FONT><FONT 
size=2>fofx.m</FONT><FONT face="Comic Sans MS" size=2>. Ahora la 
instrucción</P></FONT><FONT size=2>
<P align=justify>fplot('fofx', [0 1])</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify><IMG height=361 src="Tutorial de_archivos/image1.gif" 
width=481>produce la gráfica:</P>
<P align=justify>&nbsp;</P>
<P align=justify>Aquí, </FONT><FONT size=2>fplot</FONT><FONT 
face="Comic Sans MS" size=2> usa menos puntos para evaluar la misma función a 
intervalos más cerrados en la región donde la rapidez de cambio es mayor.</P>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.10.6 <U>Comandos gráficos</P></U></FONT><B><FONT size=2>
<P align=justify>&nbsp;</P>
<P align=justify>hold</B></FONT><FONT face="Comic Sans MS" size=2> Permite 
añadir líneas al dibujo previo</P></FONT><FONT size=2>
<P align=justify>on</FONT><FONT face="Comic Sans MS" size=2> Activa </FONT><FONT 
size=2>hold</FONT><FONT face="Comic Sans MS" size=2> </P></FONT><FONT size=2>
<P align=justify>off</FONT><FONT face="Comic Sans MS" size=2> Desactiva 
</FONT><FONT size=2>hold</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>plot(x); hold on; plot(y',':');plot(yz,'-.')</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>loglog</P></B></FONT><U><FONT face="Comic Sans MS" size=2>
<P align=justify>Sintaxis</P></U>
<P align=justify>a) loglog(x,y)</P>
<P align=justify>b) loglog(x,y,'tipo_línea')</P>
<P align=justify>c)loglog(x1',y1','tipo_línea_1',...,</P>
<P align=justify>xn,yn,'tipo_línea_n')</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>x=logspace(-1,3); loglog(x,exp(x))</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>donde </FONT><FONT size=2>logspace </FONT><FONT 
face="Comic Sans MS" size=2>tiene las formas:</P></FONT><FONT face=Arial size=2>
<P align=justify>logspace(a,b)</P>
<P align=justify>logspace(a,b,n)</P>
<P align=justify>a,b exponentes de los límites. Es decir, 10^a y 10^b </P>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>semilog(x), semilog(y)</P></B></FONT><U><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>a) semilogx(x,y)</P>
<P align=justify>b) semilogy(x,y)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>x=0:.1:20; semilogy(x,10.^x)</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>fill </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Dibuja el area interior de una curva en determinado 
color</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) fill(x,y,'c')</P>
<P align=justify>b) fill(x1,y1,'c1',...,xn,yn,cn)</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>t=0:0.5:2*pi; x=sin(t); fill(t,x,'b')</P>
<P align=justify>t=0:0.5:2*pi; x=sin(t); y=cos(t); fill(y,x,'r')</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>subplot</B></FONT><FONT face="Comic Sans MS" size=2> </P>
<P align=justify>Dibuja la pantalla en mxn subdivisioens, numeradas por el 
parámetro p, de izquierda a derecha, iniciando por la fila superior</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>subplot(m,n,p)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Ejemplo:</P></FONT><FONT size=2>
<P align=justify>vt=smvars(:,1);</P>
<P align=justify>it=smvars(:,2);</P>
<P align=justify>rang=smvars(:,3);</P>
<P align=justify>ikd=smvars(:,4);</P>
<P align=justify>subplot(2,2,1);</P>
<P align=justify>plot(vt)</P>
<P align=justify>subplot(2,2,2)</P>
<P align=justify>plot(it)</P>
<P align=justify>suplot(2,2,3)</P>
<P align=justify>plot(rang)</P>
<P align=justify>subplot(2,2,4)</P>
<P align=justify>plot(ikd)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>bar </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Crea una gráfica de barras</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) bar(y);</P>
<P align=justify>b) bar(x,y);</P>
<P align=justify>c) [xb,yb]=bar(y); =&gt; plot(xb,yb)</P>
<P align=justify>d) [xb,yb]=bar(x,y); =&gt; plot(xb,yb)</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>x=-2.8:0.2:2.8</P>
<P align=justify>bar(x,exp(-x.*x)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Nota: Los valores de x deben estar igualmente espaciados</P>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>stairs</FONT><FONT face="Comic Sans MS" size=2> </P></B>
<P align=justify>Igual que </FONT><FONT size=2>bar</FONT><FONT 
face="Comic Sans MS" size=2>, únicamente sin líneas internas</P>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>fplot </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Dibuja la gráfica de una función</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) fplot(`función', [inicio,final])</P>
<P align=justify>b) fplot(`función', [inicio,final],n)</P>
<P align=justify>c) fplot(`función', [inicio,final],n,ángulo)</P>
<P align=justify>d) [x,y]=fplot(`función', [inicio,final]) =&gt; plot(x,y)</P>
<P align=justify>n - número de puntos</P>
<P align=justify>ángulo - ángulo entre segmentos sucesivos de la 
función</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>fplot(`sin',[0,pi])</P>
<P align=justify>fplot(`tanh',[-2 2])</P>
<P align=justify>function y=func(x)</P>
<P align=justify>y=200*sin(x(:))./x(:);</P>
<P align=justify>fplot(`func',[-30 30],60,2)</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>polar </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Dibujo en coordenadas polares</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) polar(ángulo,radio)</P>
<P align=justify>b) polar(ángulo, radio, `tipo_línea')</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P>
<P align=justify>t=0:0.01:2*pi;</P>
<P align=justify>polar(t,sin(5*t))</P>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>colormap </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Colorea con sombreado el interior de una curva o 
polígono</P><U>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>colormap(colorbase)</P>
<P align=justify>donde colorbase es:</P>
<P align=justify>gray</P>
<P align=justify>hot</P>
<P align=justify>cool</P>
<P align=justify>copper</P>
<P align=justify>pink</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>t=0:0.05:2*pi; x=sin(t); y=cos(t); colormap(hot(130)); 
...</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Nota: 130 es opcional el rango 0-255</P></FONT><FONT size=2>
<P align=justify>fill(y,x,x)</FONT><FONT face="Comic Sans MS" size=2> =&gt; 
sombreado horizontal</P></FONT><FONT size=2>
<P align=justify>fill(y,x,y)</FONT><FONT face="Comic Sans MS" size=2> =&gt; 
sombreado vertical</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>5.11 Gráficos en 3 dimensiones</P></FONT><FONT size=2>
<P align=justify>plot3</B></FONT><FONT face="Comic Sans MS" size=2> </P>
<P align=justify>Dibuja líneas y puntos en 3 dimensiones</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) plot3(x,y,z)</P>
<P align=justify>b) plot3(x,y,z)</P>
<P align=justify>c) plot3(x,y,z,'tipo_línea)</P>
<P align=justify>d) 
plot3(x1,y1,z1,'tipo_línea',...,xn,yn,zn,'tipo_línea')</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P>
<P align=justify>t=0:0.05:10*pi; plot3(sin(t),cos(t),t)</P>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>contour, contour3</FONT><FONT face="Comic Sans MS" size=2> 
</P></B>
<P align=justify>Genera dibujos compuestos de líneas de valores de datos 
constantes obtenidos de una matriz de entrada</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) contour(z)</P>
<P align=justify>b) contour(z,n)</P>
<P align=justify>c) contour(x,y,z)</P>
<P align=justify>d) contour(x,y,z,n)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>contour(peeks)</P>
<P align=justify>contour(peeks,30)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>contour3</B></FONT><FONT face="Comic Sans MS" size=2> </P>
<P align=justify>Igual función de contour en 3 dimensiones</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) contour3(z)</P>
<P align=justify>b) contour3(z,n)</P>
<P align=justify>c) contour3(x,y,z)</P>
<P align=justify>d) contour3(x,y,z,n)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>contour3(peaks,30)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>meshgrid </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Genera arreglos X y Y para dibujos en 3 dimensiones</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) [X,Y] = meshgrid(x,y)</P>
<P align=justify>b) [X,Y] = meshgrid(x) =&gt; meshgrid(x,y)</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo. Evalue y dibuje la funcion z=x*exp(-x^2-y^2) sobre el 
rango -2&lt;=x&lt;=2, -2&lt;=y&lt;=2</P></FONT><FONT size=2>
<P align=justify>[X,Y]=meshgrid(-2:2:2); z=x.*exp(-x^2-y^2); ...</P>
<P align=justify>mesh(Z)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>x=-8:0.5,8; y=x; [x,y]=meshgrid(x,y);...</P>
<P align=justify>R=sqrt(x.^2+y.^2)+0.001; z=sin(R)./R;...</P>
<P align=justify>mesh(z)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>mesh, meshc y meshz </P></B></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Dibujan una superficie de malla tridimensional, crando una 
perspectiva del dibujo, sobre y bajo el plano de referencia.</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) mesh(x,y,z,c)</P>
<P align=justify>b) mesh(x,y,z)</P>
<P align=justify>c) mesh(x,y,z,c)</P>
<P align=justify>d) mesh(x,y,z)</P>
<P align=justify>e) mesh(z,c)</P>
<P align=justify>f) mesh(z)</P>
<P align=justify>g) meshc(...) =&gt; mismo que mesh</P>
<P align=justify>h) meshc(...) =&gt; mismo que mesh</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>meshc </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Añade un plano de contorno debajo del dibujo</P></FONT><B><FONT 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>meshz</FONT><FONT face="Comic Sans MS" size=2> </P></B>
<P align=justify>Añade un plano de referencia o cortina al dibujo</P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo:</P></FONT><FONT size=2>
<P align=justify>[x,y] = meshgrid(-3:2:3); z=peaks(x,y); meshc(x,y,z)</P>
<P align=justify>[x,y] = meshgrid(-3:2:3); z=peaks(x,y); 
meshz(x,y,z)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>surf, surfc </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Crean superficies sombreadas en 3 dimensiones</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) surf(x,y,z,c)</P>
<P align=justify>b) surf(x,y,z)</P>
<P align=justify>c) surf(x,y,z,c)</P>
<P align=justify>d) surf(x,y,z)</P>
<P align=justify>e) surf(z,c)</P>
<P align=justify>f) surf(z)</P>
<P align=justify>g) surfc(...) =&gt; misma <U>Sintaxis</U> que 
surf</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>[x,y]=meshgrid(-3:.2:3); z=peaks(x,y); surf(x,y,z)</P>
<P align=justify>k=5; n=2^k-1; [x,y,z]=sphere(n); c=hadamard(2^k);...</P>
<P align=justify>surf(x,y,z,c); colormap(hot)</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>hadamard</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Matriz hadamard compuesta de 1's y -1's, empleada en 
procesamiento de señales y análisis numérico</P>
<P align=justify>Ejemplo (matriz de 4*4)</P></FONT><FONT size=2>
<P align=justify>1 1 1 1</P>
<P align=justify>1 -1 1 -1</P>
<P align=justify>1 1 -1 -1</P>
<P align=justify>1 -1 -1 1</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>sphere </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Genera una esfera</P><U>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>[x,y,z] = sphere(n)</P>
<P align=justify>n - número de meridianos</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>[x,y,z]=sphere(20);</P>
<P align=justify>mesh(x,y,z)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>o con :</P></FONT><FONT size=2>
<P align=justify>colormap(hot)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>surfl </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Superficie sombreada tridimensioanl con efecto de reflexión de 
luz</P><U>
<P align=justify>Sintaxis</U>: </P></FONT><FONT face=Arial size=2>
<P align=justify>a) surfl(z)</P>
<P align=justify>b) surfl(z,s)</P>
<P align=justify>c) surfl(x,y,z)</P>
<P align=justify>d) surfl(x,y,z,s)</P>
<P align=justify>s - dirección de la luz</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>[x,y]=meshgrid(-3:0.01:3);</P>
<P align=justify>z=peaks(x,y);</P>
<P align=justify>surfl(x,y,z)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>shading </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Establece las propiedades de sombreado con color</P><U>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>shading faceted</P>
<P align=justify>shading interp</P>
<P align=justify>shading flat</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>shading flat</B></FONT><FONT face="Comic Sans MS" size=2> - 
cada segmento de la superficie tiene un valor constante determinado por el color 
de los puntos extremos del segmento o sus esquinas</P></FONT><B><FONT size=2>
<P align=justify>shading interp</B></FONT><FONT face="Comic Sans MS" size=2> - 
el color en cada segmento varia linealmente e interpolo los valores extremos o 
esquinas</P></FONT><B><FONT size=2>
<P align=justify>shading faceted</B></FONT><FONT face="Comic Sans MS" size=2> - 
utiliza sombreado "flat" con líneas de malla negras superpuestas</P>
<P align=justify>&nbsp;</P>
<P align=justify>Para el ejemplo anterior, añadiendo:</P></FONT><FONT size=2>
<P align=justify>shading interp</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>y posteriormente:</P></FONT><FONT size=2>
<P align=justify>colormap(gray);</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>axis </P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Escala y apariencia de los ejes</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) axis([xmin, xmax, ymin, ymax])</P>
<P align=justify>b) axis([xmin, xmax, ymin, ymax, zmin, zmax])</P>
<P align=justify>c) axis(`auto')</P>
<P align=justify>d) axis(`ij')</P>
<P align=justify>e) axis(`xy')</P>
<P align=justify>f) axis(`square')</P>
<P align=justify>g) axis(`equal')</P>
<P align=justify>h) axis(`off')</P>
<P align=justify>i) axis(`on')</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>donde:</P></FONT><B><FONT size=2>
<P align=justify>axis(`auto')</B></FONT><FONT face="Comic Sans MS" size=2> 
realiza el escalamiento de ejes a su modo de autoescalamiento por 
defecto.</P></FONT><B><FONT size=2>
<P align=justify>axis(`ij')</B></FONT><FONT face="Comic Sans MS" size=2> dibuja 
nuevamente la gráfica. </P>
<P align=justify>El eje y es vertical y es numerado de arriba hacia abajo. </P>
<P align=justify>El eje j es horizontal y es numerado de izquierda a 
derecha.</P></FONT><B><FONT size=2>
<P align=justify>axis(`xy')</B></FONT><FONT face="Comic Sans MS" size=2> regresa 
la forma de ejes cartesianos que existe por <U>defecto</U>. El eje x es 
horizontal y se numera de izquierda a derecha. El eje y es vertical y se numera 
de abajo hacia arriba</P></FONT><B><FONT size=2>
<P align=justify>axis(`square')</B></FONT><FONT face="Comic Sans MS" size=2> 
determina que la región de los ejes es cuadrada</P></FONT><B><FONT size=2>
<P align=justify>axis(`equal')</B></FONT><FONT face="Comic Sans MS" size=2> 
indica que los factores de escalamiento y marcas incrementales a lo largo de los 
ejes x y y son iguales.</P></FONT><B><FONT size=2>
<P align=justify>axis(`off')</B></FONT><FONT face="Comic Sans MS" size=2> 
desactiva las etiquetas de los ejes y las marcas</P></FONT><B><FONT size=2>
<P align=justify>axis(`on')</B></FONT><FONT face="Comic Sans MS" size=2> activa 
las etiquetas de los ejes y las marcas</P>
<P align=justify>Para el ejemplo último:</P></FONT><FONT size=2>
<P align=justify>...</P>
<P align=justify>axis([-3 3 -3 3 -8 8])</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>fill3</B></FONT><FONT face="Comic Sans MS" size=2> colorea 
polígonos de 3 dimensiones</P></FONT><FONT face=Arial size=2>
<P align=justify>a) fill3(x,y,z,'c')</P>
<P align=justify>b) fill3(x1,y1,z1,...,xn,yn,zn)</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>colormap(hot)</P>
<P align=justify>fill3(rand(3,4), rand(3,4), rand(3,4), 
rand(3,4))</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>rand</B></FONT><FONT face="Comic Sans MS" size=2> matrices y 
números aleatorios distribuidos uniformemente</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) rand(n) - matriz de nxn</P>
<P align=justify>b) rnad(m,n) - matriz de mxn</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>fill3(rand(20), rand(20), rand(20), rand(20</FONT><FONT 
face="Comic Sans MS" size=2>))</P>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>&nbsp;</P>
<P align=justify>load</B></FONT><FONT face="Comic Sans MS" size=2> carga en el 
area de trabajo un archivo (imagen, sonido, datos, etc)</P><U>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>a) load archivo</P>
<P align=justify>b) load archivo.ext</P>
<P align=justify>donde:</P>
<P align=justify>ext - extensión</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>load clown</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>image</B></FONT><FONT face="Comic Sans MS" size=2> crea un 
objeto imagen y lo presenta</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) image(x)</P>
<P align=justify>b) image(x,y,x)</P>
<P align=justify>c) presenta la matriz c como una imagen</P>
<P align=justify>d) especifica los límites de los datos de la imagen en los ejes 
x e y. En b), x e y son vectores</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>load clown</P>
<P align=justify>colormap(map)</P>
<P align=justify>image(x)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>brighten</B></FONT><FONT face="Comic Sans MS" size=2> hace más 
brillante o más obscura la imagen</P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>a) brighten(alfa)</P>
<P align=justify>b) brighten(map,alfa)</P>
<P align=justify>donde:</P>
<P align=justify>0&lt;alfa&lt;1 más brillante</P>
<P align=justify>-1&lt;alfa&lt;0 más obscuro</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Del ejemplo anterior:</P>
<P align=justify>...</P></FONT><FONT size=2>
<P align=justify>brighten(0.6)</P>
<P align=justify>ó brighten(-0.6)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>clf</B></FONT><FONT face="Comic Sans MS" size=2> borra la 
figura</P>
<P align=justify>&nbsp;</P></FONT><B><FONT size=2>
<P align=justify>sound</B></FONT><FONT face="Comic Sans MS" size=2> convierte un 
vector en sonido (en computadoras sparc y macintosh) </P><U>
<P align=justify>Sintaxis</P></U></FONT><FONT face=Arial size=2>
<P align=justify>a) sound(y)</P>
<P align=justify>b) sound(y,Fs)</P>
<P align=justify>donde:</P>
<P align=justify>Fs frecuencia especificada en Hz</P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>load train</P>
<P align=justify>sound(y,Fs)</P>
<P align=justify>t=(0:length(y)-1)/Fs;</P>
<P align=justify>plot(t,y)</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>5.12 Archivos de disco</P></B></FONT><FONT face=Arial>
<P align=justify>5.12.1 <U>Manipulación de Archivos de Disco</P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Algunos comandos utilizados para la manipulación de archivos de 
disco son </FONT><FONT size=2>dir, type, delete</FONT><FONT face="Comic Sans MS" 
size=2> y </FONT><FONT size=2>cd</FONT><FONT face="Comic Sans MS" size=2>. Si la 
extención no se especifica, MATLAB utiliza .m automáticamente. El comando 
</FONT><FONT size=2>diary</FONT><FONT face="Comic Sans MS" size=2> crea un 
diario de tu sesión de MATLAB en un archivo de disco. Para más información 
utiliza la Guía de Referencia de MATLAB ó el comando help. </P>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.12.2 <U>Ejecutando Programas Externos</U> </P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>El simbolo "!" le indica a MATLAB que el resto de la línea de 
entrada es un comando para el sistema operativo. Por ejemplo,</P></FONT><FONT 
size=2>
<P align=justify>! edt darwin.m</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>invoca un editor llamado </FONT><FONT size=2>edt</FONT><FONT 
face="Comic Sans MS" size=2> en un archivo llamado </FONT><FONT 
size=2>darwin.m.</FONT><FONT face="Comic Sans MS" size=2> Luego que este 
programa sea completado, el sistema operativo devuelve el control a MATLAB.</P>
<P align=justify>&nbsp;</P></FONT><FONT face=Arial>
<P align=justify>5.12.3 <U>Importando y Exportando Datos</P></U></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Puedes introducir datos de otros programas a MATLAB por varios 
métodos. Similarmente, puedes exportar datos de MATLAB a otros programas. 
También puedes hacer que tus programas manipulen datos directamente en 
archivos-MAT, el cúal es el formato de archivo utilizado por MATLAB. Para 
información acerca de las técnicas utilizadas para importar y exportar datos 
consulte la sección de Importando y Exportando Datos de la guía de MATLAB ó 
utilice al comando help de MATLAB. </P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>5.13 INDICE ALFABETICO </P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>axis, all, any, bar, break, brighten, clf, for, colormap, conj, 
contour, contour3, det, diag, else, elseif, eig, expm, fclose, fill, fill3, fft, 
fftn, function, fopen, fplot, fread, fwrite, grid, gtext, hadamard, hold, if, 
ifft, ifftn, imag, image, inv, loglog, load, lu, mesh, meshc, meshz, meshgrid, 
ode23, ode45, peaks, plot, plot3, poly, reshape, rot90, sphere, tril, triu, 
pascal, polar, real, toplitz, rand, reshape, semilog, semilogy, shading (flat 
interp faceted), size, sound, stairs, subplot, surf, surfc, surfl, text, title, 
xlabel, ylabel, while, zeros. </P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>6. Simulink</P></B></I></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Simulink es una herramienta para el modelaje, análisis y 
simulación de una amplia variedad de sistemas físicos y matemáticos, inclusive 
aquellos con elementos no lineales y aquellos que hacen uso de tiempos continuos 
y discretos. Como una extensión de MatLab, Simulink adiciona muchas 
características específicas a los sistemas dinámicos, mientras conserva toda la 
funcionalidad de propósito general de MatLab. Así Simulink no es completamente 
un programa separado de MatLab, sino un anexo a él. El ambiente de MatLab está 
siempre disponible mientras se ejecuta una simulación en Simulink.</P>
<P align=justify>Simulink tiene dos fases de uso: la definición del modelo y el 
análisis del modelo. La definición del modelo significa construir el modelo a 
partir de elementos básicos construidos previamente, tal como, integradores, 
bloques de ganancia o servomotores. El análisis del modelo significa realizar la 
simulación, linealización y determinar el punto de equilibrio de un modelo 
previamente definido.</P>
<P align=justify>Para simplificar la definición del modelo Simulink usa 
diferentes clases de ventanas llamadas ventanas de diagramas de bloques. En 
estas ventanas se puede crear y editar un modelo gráficamente usando el ratón. 
Simulink usa un ambiente gráfico lo que hace sencillo la creación de los modelos 
de sistemas.</P>
<P align=justify>Después de definir un modelo este puede ser analizado 
seleccionando una opción desde los menús de Simulink o entrando comandos desde 
la línea de comandos de MatLab.</P>
<P align=justify>Simulink puede simular cualquier sistema que pueda ser definido 
por ecuaciones diferenciales continuas y ecuaciones diferenciales discretas. 
Esto significa que se puede modelar sistemas continuos en el tiempo, discretos 
en el tiempo o sistemas híbridos.</P>
<P align=justify>Simulink usa diagramas de bloques para representar sistemas 
dinámicos. Mediante una interface gráfica con el usuario se pueden arrastrar los 
componentes desde una librería de bloques existentes y luego interconectarlos 
mediante conectores y alambre. La ventana principal de Simulink se activa 
escribiendo simulink en la línea de comandos de MatLab, y se muestra a 
continuación:</P>
<P align=justify>Haciendo doble click en cualquiera de las librerías presentes 
en esta ventana se abrirá otra ventana conteniendo una cantidad de bloques 
relativos a dicha librería.</P>
<P align=justify>Para realizar un sistema debe abrirse una nueva ventana de 
diagrama de bloques seleccionando la opción file del menú principal del Simulink 
y allí la opción new. En esta nueva ventana se colocarán todos los bloques 
interconectados que formarán el sistema deseado.</P>
<P align=justify>&nbsp;</P>
<P align=justify>Como ejemplo se ha tomado un generador de ondas seno de la 
librería de fuentes "sources" y un osciloscopio de la librería "sinks", ambos se 
unieron mediante un conector usando el ratón. Este sistema se almacena como un 
archivo-m.</P>
<P align=justify>Haciendo doble click sobre cada elemento del sistema se pueden 
ver y modificar sus características.</P>
<P align=justify>Por ejemplo, al generador seno se le puede modificar su 
amplitud, frecuencia y fase. Al osciloscopio se le definen las escalas 
horizontal y vertical. </P>
<P align=justify>Para ejecutar el programa se usa la opción simulation en el 
menú de la ventana del archivo-m creado.</P>
<P align=justify>En este submenú está la opción start que permite ejecutar el 
programa. También está la opción parameters que activa el panel de control de 
Simulink en donde se definen los métodos y parámetros usados para la simulación, 
tal como se muestra a continuación:</P>
<P align=justify>Al ejecutar el programa seno.m creado mediante simulink, se 
puede observar la respuesta al hacer doble click en el osciloscopio.</P>
<P align=justify>Existen numerosos bloques y funciones incorporados en las 
librerías de simulink que pueden ser empleados para simular cualquier 
sistema.</P>
<P align=justify>Por ejemplo, para implementar un sistema que emplea un 
controlador PID tenemos:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>En este diagrama se tiene al bloque llamado PID que fue 
definido previamente y agrupado como uno solo. El contenido de dicho bloque se 
obtiene haciendo doble click sobre él. A continuación se muestra el bloque 
PID:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>6.1 Acelerador de Simulink</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Para incrementar la velocidad de Simulink se debe instalar el 
acelerador "Accelerator". Este permite automáticamente generar una versión 
mejorada de los modelos los cuales correrán diez veces más rápido que el 
original. El acelerador puede ser usado sobre modelos continuos, discretos en el 
tiempo y híbridos. </P>
<P align=justify>El acelerador trabaja generando y compilando un código-C para 
un modelo dado. Una vez se completa la compilación, la simulación es ejecutada 
en la ventada de modelos de Simulink exactamente igual que antes sólo que más 
rápidamente. El propósito del acelerador es aumentar la velocidad de 
simulación.</P>
<P align=justify>Si el programa MatLab posee instalado el "Accelerator" podrá 
iniciarse la acción aceleradora seleccionando la opción simulation en el menú 
principal del Simulink y dentro de esta seleccionando la opción Accelerate. Esta 
acción es totalmente transparente en el sentido de que el incremento de la 
velocidad se presenta sin ningún otro requerimiento por parte del usuario.</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>6.2 Generador de código-C en Simulink</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Una vez se ha creado un modelo dinámico en Simulink, se puede 
invocar el generador de código-C que permite convertir el diagrama de bloques 
implementado en un código C. Este puede ser útil para varios propósitos: puede 
ser usado para control en tiempo real, simulación en tiempo real o simulación 
acelerada en tiempo no real. Sus aplicaciones pueden ser control de movimiento, 
control de procesos, sistemas automotores, equipos médicos, robótica, etc.</P>
<P align=justify>El código-C es diseñado tal que puede ser ejecutado en tiempo 
real. No requiere ser escrito manualmente por un programador pues es creado a 
nivel de diagramas de bloques en Simulink. El código generado puede correr sobre 
un amplio rango de hardware ubicado en estaciones de trabajo, PC o 
microprocesadores. Este código es la forma en la que puede usare el Simulink 
para adquisición de datos.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>7. Comandos de MatLab</P></B></I></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>7.1 General purpose commands:</P></FONT><U><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Managing commands and functions</U>:</P></B>
<P align=justify>help - On-line documentation. </P>
<P align=justify>what - Directory listing of M-, MAT- and MEX-files.</P>
<P align=justify>type - List M-file.</P>
<P align=justify>lookfor - Keyword search through the HELP entries.</P>
<P align=justify>which - Locate functions and files.</P>
<P align=justify>demo - Run demos.</P>
<P align=justify>path - Control MATLAB's search path.</P><U>
<P align=justify>&nbsp;</P><B>
<P align=justify>Managing variables and the workspace</U>:</P></B>
<P align=justify>who - List current variables.</P>
<P align=justify>whos - List current variables, long form.</P>
<P align=justify>load - Retrieve variables from disk.</P>
<P align=justify>save - Save workspace variables to disk.</P>
<P align=justify>clear - Clear variables and functions from memory.</P>
<P align=justify>pack - Consolidate workspace memory.</P>
<P align=justify>size - Size of matrix.</P>
<P align=justify>length - Length of vector.</P>
<P align=justify>disp - Display matrix or text.</P><U>
<P align=justify>&nbsp;</P><B>
<P align=justify>Working with files and the operating system</U>:</P></B>
<P align=justify>cd - Change current working directory.</P>
<P align=justify>dir - Directory listing.</P>
<P align=justify>delete - Delete file.</P>
<P align=justify>getenv - Get environment value.</P>
<P align=justify>! - Execute operating system command.</P>
<P align=justify>unix - Execute operating system command &amp; return 
result.</P>
<P align=justify>diary - Save text of MATLAB session.</P>
<P align=justify>&nbsp;</P><B><U>
<P align=justify>Controlling the command window</U>:</P></B>
<P align=justify>cedit - Set command line edit/recall facility parameters.</P>
<P align=justify>clc - Clear command window.</P>
<P align=justify>home - Send cursor home.</P>
<P align=justify>format - Set output format.</P>
<P align=justify>echo - Echo commands inside script files. </P>
<P align=justify>more - Control paged output in command window.</P>
<P align=justify>&nbsp;</P><B><U>
<P align=justify>Starting and quitting from MATLAB</U>:</P></B>
<P align=justify>quit - Terminate MATLAB.</P>
<P align=justify>startup - M-file executed when MATLAB is invoked.</P>
<P align=justify>matlabrc - Master startup M-file.</P>
<P align=justify>&nbsp;</P><B><U>
<P align=justify>General information</U>:</P></B>
<P align=justify>info - Information about MATLAB and The MathWorks, Inc.</P>
<P align=justify>subscribe - Become subscribing user of MATLAB.</P>
<P align=justify>hostid - MATLAB server host identification number.</P>
<P align=justify>whatsnew - Information about new features not yet 
documented.</P>
<P align=justify>ver - MATLAB, SIMULINK, and TOOLBOX version information.</P><U>
<P align=justify>&nbsp;</P><B>
<P align=justify>Operators and special characters</U>:</P></B>
<P align=justify>Char Name HELP topic</P>
<P align=justify>+ Plus arith</P>
<P align=justify>- Minus arith</P>
<P align=justify>* Matrix multiplication arith</P>
<P align=justify>.* Array multiplication arith</P>
<P align=justify>^ Matrix power arith</P>
<P align=justify>.^ Array power arith</P>
<P align=justify>\ Backslash or left division slash</P>
<P align=justify>/ Slash or right division slash</P>
<P align=justify>./ Array division slash</P>
<P align=justify>kron Kronecker tensor product kron</P>
<P align=justify>: Colon colon</P>
<P align=justify>( ) Parentheses paren</P>
<P align=justify>[ ] Brackets paren</P>
<P align=justify>. Decimal point punct</P>
<P align=justify>.. Parent directory punct</P>
<P align=justify>... Continuation punct</P>
<P align=justify>, Comma punct</P>
<P align=justify>; Semicolon punct</P>
<P align=justify>% Comment punct</P>
<P align=justify>! Exclamation point punct</P>
<P align=justify>' Transpose and quote punct</P>
<P align=justify>= Assignment punct</P>
<P align=justify>== Equality relop</P>
<P align=justify>&lt; &gt; Relational operators relop</P>
<P align=justify>&amp; Logical AND relop</P>
<P align=justify>| Logical OR relop</P>
<P align=justify>~ Logical NOT relop</P>
<P align=justify>xor Logical EXCLUSIVE OR xor</P>
<P align=justify>&nbsp;</P><B><U>
<P align=justify>Logical characteristics</U>:</P></B>
<P align=justify>exist - Check if variables or functions are defined.</P>
<P align=justify>any - True if any element of vector is true.</P>
<P align=justify>all - True if all elements of vector are true.</P>
<P align=justify>find - Find indices of non-zero elements.</P>
<P align=justify>isnan - True for Not-A-Number.</P>
<P align=justify>isinf - True for infinite elements.</P>
<P align=justify>finite - True for finite elements.</P>
<P align=justify>isempty - True for empty matrix.</P>
<P align=justify>issparse - True for sparse matrix.</P>
<P align=justify>isstr - True for text string.</P>
<P align=justify>isglobal - True for global variables.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P><U>
<P align=justify>Control System Toolbox Commands</U></FONT><FONT 
face=Arial>:</P></FONT><B><I><FONT face="Comic Sans MS" size=2>
<P align=justify>Model building</I>:</P></B>
<P align=justify>append - Append system dynamics.</P>
<P align=justify>augstate - Augment states as outputs.</P>
<P align=justify>blkbuild - Build state-space system from block diagram.</P>
<P align=justify>cloop - Close loops of system.</P>
<P align=justify>connect - Block diagram modeling.</P>
<P align=justify>conv - Convolution of two polynomials.</P>
<P align=justify>destim - Form discrete state estimator from gain matrix.</P>
<P align=justify>dreg - Form discrete controller/estimator from gain 
matrices.</P>
<P align=justify>drmodel - Generate random discrete model.</P>
<P align=justify>estim - Form continuous state estimator from gain matrix.</P>
<P align=justify>feedback - Feedback system connection.</P>
<P align=justify>ord2 - Generate A,B,C,D for a second-order system.</P>
<P align=justify>pade - Pade approximation to time delay.</P>
<P align=justify>parallel - Parallel system connection.</P>
<P align=justify>reg - Form continuous controller/estimator from gain 
matrices.</P>
<P align=justify>rmodel - Generate random continuous model.</P>
<P align=justify>series - Series system connection.</P>
<P align=justify>ssdelete - Delete inputs, outputs, or states from model.</P>
<P align=justify>ssselect - Select subsystem from larger system.</P>
<P align=justify>&nbsp;</P><B><I>
<P align=justify>Model conversions&gt;:</P></B></I>
<P align=justify>c2d - Continuous to discrete-time conversion.</P>
<P align=justify>c2dm - Continuous to discrete-time conversion with method.</P>
<P align=justify>c2dt - Continuous to discrete conversion with delay.</P>
<P align=justify>d2c - Discrete to continuous-time conversion.</P>
<P align=justify>d2cm - Discrete to continuous-time conversion with method.</P>
<P align=justify>poly - Roots to polynomial conversion.</P>
<P align=justify>residue - Partial fraction expansion.</P>
<P align=justify>ss2tf - State-space to transfer function conversion.</P>
<P align=justify>ss2zp - State-space to zero-pole conversion.</P>
<P align=justify>tf2ss - Transfer function to state-space conversion.</P>
<P align=justify>tf2zp - Transfer function to zero-pole conversion.</P>
<P align=justify>zp2tf - Zero-pole to transfer function conversion.</P>
<P align=justify>zp2ss - Zero-pole to state-space conversion.</P>
<P align=justify>&nbsp;</P><B><I>
<P align=justify>Model reduction</I>:</P></B>
<P align=justify>balreal - Balanced realization.</P>
<P align=justify>dbalreal - Discrete balanced realization.</P>
<P align=justify>dmodred - Discrete model order reduction.</P>
<P align=justify>minreal - Minimal realization and pole-zero cancellation.</P>
<P align=justify>modred - Model order reduction.</P>
<P align=justify>&nbsp;</P><B><I>
<P align=justify>Model realizations</I>:</P></B>
<P align=justify>canon - Canonical form.</P>
<P align=justify>ctrbf - Controllability staircase form.</P>
<P align=justify>obsvf - Observability staircase form.</P>
<P align=justify>ss2ss - Apply similarity transform.</P>
<P align=justify>&nbsp;</P><B><I>
<P align=justify>Model properties</I>:</P></B>
<P align=justify>covar - Continuous covariance response to white noise.</P>
<P align=justify>ctrb - Controllability matrix.</P>
<P align=justify>damp - Damping factors and natural frequencies.</P>
<P align=justify>dcgain - Continuous steady state (D.C.) gain.</P>
<P align=justify>dcovar - Discrete covariance response to white noise.</P>
<P align=justify>ddamp - Discrete damping factors and natural frequencies.</P>
<P align=justify>ddcgain - Discrete steady state (D.C.) gain.</P>
<P align=justify>dgram - Discrete controllability and observability 
gramians.</P>
<P align=justify>dsort - Sort discrete eigenvalues by magnitude.</P>
<P align=justify>eig - Eigenvalues and eigenvectors.</P>
<P align=justify>esort - Sort continuous eigenvalues by real part.</P>
<P align=justify>gram - Controllability and observability gramians.</P>
<P align=justify>obsv - Observability matrix.</P>
<P align=justify>printsys - Display system in formatted form.</P>
<P align=justify>roots - Polynomial roots.</P>
<P align=justify>tzero - Transmission zeros.</P>
<P align=justify>tzero2 - Transmission zeros using random perturbation 
method.</P>
<P align=justify>&nbsp;</P><B><U>
<P align=justify>Time response</U>:</P></B>
<P align=justify>dimpulse - Discrete unit sample response.</P>
<P align=justify>dinitial - Discrete initial condition response.</P>
<P align=justify>dlsim - Discrete simulation to arbitrary inputs.</P>
<P align=justify>dstep - Discrete step response.</P>
<P align=justify>filter - SISO z-transform simulation.</P>
<P align=justify>impulse - Impulse response.</P>
<P align=justify>initial - Continuous initial condition response.</P>
<P align=justify>lsim - Continuous simulation to arbitrary inputs.</P>
<P align=justify>ltitr - Low level time response function.</P>
<P align=justify>step - Step response.</P>
<P align=justify>stepfun - Step function.</P>
<P align=justify>&nbsp;</P><B><U>
<P align=justify>Frequency response</U>:</P></B>
<P align=justify>bode - Bode plot (frequency response).</P>
<P align=justify>dbode - Discrete Bode plot (frequency response).</P>
<P align=justify>dnichols - Discrete Nichols plot.</P>
<P align=justify>dnyquist - Discrete Nyquist plot.</P>
<P align=justify>dsigma - Discrete singular value frequency plot.</P>
<P align=justify>fbode - Fast Bode plot for continuous systems.</P>
<P align=justify>freqs - Laplace-transform frequency response.</P>
<P align=justify>freqz - Z-transform frequency response.</P>
<P align=justify>ltifr - Low level frequency response function.</P>
<P align=justify>margin - Gain and phase margins.</P>
<P align=justify>nichols - Nichols plot.</P>
<P align=justify>ngrid - Draw grid lines for Nichols plot.</P>
<P align=justify>nyquist - Nyquist plot.</P>
<P align=justify>sigma - Singular value frequency plot.</P>
<P align=justify>&nbsp;</P><B><U>
<P align=justify>Root locus</U>:</P></B>
<P align=justify>pzmap - Pole-zero map.</P>
<P align=justify>rlocfind - Interactive root locus gain determination.</P>
<P align=justify>rlocus - Evans root-locus.</P>
<P align=justify>sgrid - Draw continuous root locus wn,z grid.</P>
<P align=justify>zgrid - Draw discrete root locus wn,z grid.</P>
<P align=justify>&nbsp;</P><B><U>
<P align=justify>Gain selection</U>:</P></B>
<P align=justify>acker - SISO pole placement.</P>
<P align=justify>dlqe - Discrete linear-quadratic estimator design.</P>
<P align=justify>dlqew - General discrete linear quadratic estimator design.</P>
<P align=justify>dlqr - Discrete linear-quadratic regulator design.</P>
<P align=justify>dlqry - Discrete regulator design with weighting on 
outputs.</P>
<P align=justify>lqe - Linear-quadratic estimator design.</P>
<P align=justify>lqed - Discrete estimator design from continuous cost 
function.</P>
<P align=justify>lqe2 - Linear quadratic estimator design using Schur 
method.</P>
<P align=justify>lqew - General linear-quadratic estimator design.</P>
<P align=justify>lqr - Linear-quadratic regulator design.</P>
<P align=justify>lqrd - Discrete regulator design from continuous cost 
function.</P>
<P align=justify>lqry - Regulator design with weighting on outputs.</P>
<P align=justify>lqr2 - Linear quadratic regulator design using Schur 
method.</P>
<P align=justify>place - Pole placement.</P>
<P align=justify>&nbsp;</P><B><U>
<P align=justify>Equation solution</U>:</P></B>
<P align=justify>are - Algebraic Riccati equation solution.</P>
<P align=justify>dlyap - Discrete Lyapunov equation solution.</P>
<P align=justify>lyap - Continuous Lyapunov equation solution.</P>
<P align=justify>lyap2 - Lyapunov equation solution using diagonalization.</P>
<P align=justify>&nbsp;</P><B><U>
<P align=justify>Demonstrations</U>:</P></B>
<P align=justify>ctrldemo - Introduction to the Control Toolbox.</P>
<P align=justify>boildemo - LQG design of boiler system.</P>
<P align=justify>jetdemo - Classical design of jet transport yaw damper.</P>
<P align=justify>diskdemo - Digital control design of hard disk controller.</P>
<P align=justify>kalmdemo - Kalman filter design and simulation.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><I><FONT face=Arial>
<P align=justify>8. Aplicando Matlab al control de procesos</P></I></FONT><FONT 
face="Comic Sans MS">
<P align=justify>8.1 Respuesta en el dominio del tiempo</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Para obtener la respuesta de un sistema en el tiempo ante una 
entrada estándar, debe primero definirse el sistema. Para ello puede definirse 
en MatLab la función de transferencia propia del sistema o las ecuaciones de 
estado.</P>
<P align=justify>La función de transferencia de un sistema es una relación 
formada por un numerador y un denominador:</P>
<P align=justify></P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>En MatLab debe definirse el numerador Y(s) y el denominador 
U(s) como vectores, cuyos elementos son los coeficientes de los polinomios del 
numerador y del denominador en potencias decrecientes de S. Por ejemplo, para 
definir la función de transferencia:</P>
<P align=justify></P>
<P align=justify>&gt;&gt;y=[1];</P>
<P align=justify>&gt;&gt;u=[1 0.25 1];</P>
<P align=justify>&nbsp;</P>
<P align=justify>Para determinar la respuesta en el tiempo para una entrada 
escalón unitario de este sistema se usa el comandos step indicando el vector del 
numerador y del denominador entre paréntesis. step(num,den)</P>
<P align=justify>&gt;&gt;step(y,u)</P>
<P align=justify>&nbsp;</P>
<P align=justify>MatLab presenta la respuesta en el tiempo en la ventana de 
figuras:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Puede definirse el tiempo en el cual se desea la respuesta al 
escalón, mediante un vector de tiempo T, step(num,den,T)</P>
<P align=justify>&gt;&gt;t=0:0.1:20;</P>
<P align=justify>&gt;&gt;step(y,u,t)</P>
<P align=justify>&nbsp;</P>
<P align=justify>Se define t como un vector cuyo elemento inicial es 0, su 
elemento final es 20 y existen elementos que son el incremento desde 0 hasta 20 
de 0.1 en 0.1. Al ejecutar el comando step para y y u se obtiene en la ventana 
de figuras la respuesta escalón para los primeros 20 segundos.</P>
<P align=justify>Otra forma de definir el sistema en MatLab es usando las 
ecuaciones de estado de la forma: </P>
<P align=justify>x = Ax + Bu</P>
<P align=justify>y = Cx + Du</P>
<P align=justify>&nbsp;</P>
<P align=justify>MatLab permite hacer la conversión de una función de 
transferencia a su equivalente en ecuaciones de estado, mediante el comando 
tf2ss. Se deben especificar las cuatro matrices de estado de la forma:</P>
<P align=justify>[A,B,C,D]=tf2ss(num,den)</P>
<P align=justify>&nbsp;</P>
<P align=justify>Para el ejemplo anterior tenemos:</P>
<P align=justify>&gt;&gt;[a,b,c,d]=tf2ss(y,u)</P>
<P align=justify>a =</P>
<P align=justify>-0.2500 -1.0000</P>
<P align=justify>1.0000 0</P>
<P align=justify>b =</P>
<P align=justify>1</P>
<P align=justify>0</P>
<P align=justify>c =</P>
<P align=justify>0 1</P>
<P align=justify>d =</P>
<P align=justify>0</P>
<P align=justify>&nbsp;</P>
<P align=justify>Se puede hacer la conversión de una ecuación de estado a su 
equivalente función de transferencia, mediante el comando ss2tf. Se deben 
especificar los vectores para almacenar los coeficientes del polinomio numerador 
y del denominador. Su </P><U>
<P align=justify>Sintaxis</U> es:</P></FONT><FONT face=Arial size=2>
<P align=justify>[num,den]=ss2tf(a,b,c,d)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;[num,den]=ss2tf(a,b,c,d)</P>
<P align=justify>num =</P>
<P align=justify>0 0 1.0000</P>
<P align=justify>den =</P>
<P align=justify>1.0000 0.2500 1.0000</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Para obtener la respuesta escalón de un sistema a partir de las 
ecuaciones de estado se usa el</P>
<P align=justify>comando step con la </P><U>
<P align=justify>Sintaxis</U>:</P></FONT><FONT face=Arial size=2>
<P align=justify>step(A,B,C,D)</P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;step(a,b,c,d)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Para obtener la respuesta en el tiempo para una entrada impulso 
unitario se usa el comando impulse, con Sintaxis idéntica a la utilizada con el 
comando step:</P>
<P align=justify>Si se define el sistema en MatLab por los polinomios del 
numerador y denominador de la función de transferencia tenemos:</P></FONT><FONT 
size=2>
<P align=justify>» y=[1 5 4];</P>
<P align=justify>» u=[1 6 11 6];</P>
<P align=justify>» impulse(y,u)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Si por el contrario el sistema se define en MatLab por las 
ecuaciones de estado:</P></FONT><FONT size=2>
<P align=justify>» [A,B,C,D]=tf2ss(y,u)</P>
<P align=justify>A =</P>
<P align=justify>-6 -11 -6</P>
<P align=justify>1 0 0</P>
<P align=justify>0 1 0</P>
<P align=justify>B =</P>
<P align=justify>1</P>
<P align=justify>0</P>
<P align=justify>0</P>
<P align=justify>C =</P>
<P align=justify>1 5 4</P>
<P align=justify>D =</P>
<P align=justify>0</P>
<P align=justify>» impulse(A,B,C,D)</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify>En ambos casos, MatLab presenta la respuesta en el tiempo en la 
ventana de figuras:</P>
<P align=justify>&nbsp;</P>
<P align=justify>MatLab permite, además de obtener la respuesta en el tiempo 
para una entrada escalón o impulso, también obtener respuesta para otras 
entradas tal como rampas o sinusoides. El comando lsim permite obtener la 
respuesta en el tiempo para un sistema con una entrada u, donde u se define como 
una función del tiempo. </P>
<P align=justify>La Sintaxis de este comando es: lsim(A,B,C,D,U,T) usando las 
matrices de estado o lsim(NUM,DEN,U,T) usando la función de transferencia.</P>
<P align=justify>Para obtener la respuesta en el tiempo para una función rampa, 
se define U de la siguiente forma:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;T=0:0.1:10</P>
<P align=justify>&gt;&gt;U=T;</P>
<P align=justify>&gt;&gt;NUM=[1];</P>
<P align=justify>&gt;&gt;DEN=[1 0.25 1];</P>
<P align=justify>&gt;&gt;[Y,X]=lsim(NUM,DEN,U,T);</P>
<P align=justify>&gt;&gt;PLOT(T,Y,T,U)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Al hacer U=T se está definiendo la función rampa. T es el 
vector de tiempo variando desde 0 hasta 10</P>
<P align=justify>seg. NUM y DEN son los vectores de los coeficientes 
decrecientes en potencia de S de los polinomios del numerador y del denominador 
respectivamente. En la variable Y se almacena la salida del sistema en función 
del tiempo T. El comando plot permite presentar en la ventana de figuras la 
variable Y (salida) y la entrada U (rampa) en función del tiempo, 
obteniéndose:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>8.2 Respuesta en el dominio de la 
frecuencia</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Para el estudio de un sistema en el dominio de la frecuencia 
existen tres herramientas disponibles en MatLab como son: los diagramas de Bode, 
de Nyquist y de Nichols.</P>
<P align=justify>Para obtener el diagrama de Bode de una función de 
transferencia, se definen dos vectores cuyos elementos son los coeficientes de 
los polinomios del numerador y del denominador en potencias decrecientes de S. 
Estos vectores son usados en el comando bode con la siguiente </P><U>
<P align=justify>Sintaxis</U>: </P></FONT><FONT face=Arial size=2>
<P align=justify>bode(num,den). </P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Se define la función de transferencia:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo</P>
<P align=justify>&gt;&gt;y=[1];</P>
<P align=justify>&gt;&gt;u=[1 0.25 1];</P>
<P align=justify>&gt;&gt;bode(y,u)</P>
<P align=justify>&nbsp;</P>
<P align=justify>MatLab presenta el diagrama de bode en la ventana de 
figuras:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Otro formato mediante el cual el comando bode presenta el 
diagrama de bode, es a través de las ecuaciones de estado representadas por las 
matrices de estado (A,B,C,D). Su </P><U>
<P align=justify>Sintaxis</U> es:</P></FONT><FONT face=Arial size=2>
<P align=justify>bode(A,B,C,D).</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Para especificar un rango deseado de frecuencias en las cuales 
se desea obtener el diagrama de Bode, se emplea un vector de frecuencias en el 
que se especifica la frecuencia inicial, el incremento y la frecuencia final. 
Por ejemplo:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;W=0:0.1:100;</P>
<P align=justify>&gt;&gt;bode(y,u,W)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Este comando muestra el diagrama de Bode entre 0 y 100 
rad/s.</P>
<P align=justify>Otra herramienta de análisis en el dominio en la frecuencia que 
ofrece MatLab es el diagrama de Nichols. Para obtener el diagrama de Nichols se 
utiliza el comando nichols, cuya Sintaxis es idéntica a la del comando bode: 
nichols(A,B,C,D,W) si se emplean las matrices de estado o nichols(num,den,W) si 
se emplea la función de transferencia.</P>
<P align=justify>&nbsp;</P>
<P align=justify>Si se define y como el vector de los coeficientes del polinomio 
del numerador </FONT><FONT size=2>y</FONT><FONT face="Comic Sans MS" size=2> 
</FONT><FONT size=2>u</FONT><FONT face="Comic Sans MS" size=2> como el 
deldenominador:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;y=[0 0 100];</P>
<P align=justify>&gt;&gt;u=[0.04 1 0];</P>
<P align=justify>&gt;&gt;nichols(y,u)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>MatLab presenta en la ventana de figuras el diagrama de 
Nichols:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Otra herramienta de análisis en el dominio en la frecuencia que 
ofrece MatLab es el diagrama de Nyquist. Para obtenerlo se utiliza el comando 
nyquist, cuya <U>Sintaxis</U> es idéntica a la del comando bode y nichols: 
nyquist(A,B,C,D,W) si se emplean las matrices de estado o nyquist(num,den,W) si 
se emplea la función de transferencia.</P>
<P align=justify>Si se define </FONT><FONT size=2>y</FONT><FONT 
face="Comic Sans MS" size=2> como el vector de los coeficientes del polinomio 
del numerador y </FONT><FONT size=2>u</FONT><FONT face="Comic Sans MS" size=2> 
como el del denominador:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;y=[1];</P>
<P align=justify>&gt;&gt;u=[1 6 5];</P>
<P align=justify>&gt;&gt;nyquist(y,u)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>MatLab presenta en la ventana de figuras el diagrama de 
Nyquist:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Para obtener el margen de ganancia, el margen de fase, la 
frecuencia de cruce de ganancia y la frecuencia de cruce de fase MatLab dispone 
del comando margin. Las diferentes formas de utilizar este comando 
son:</P></FONT><B><FONT size=2>
<P align=justify>[Gm,Pm,Wcg,Wcp] = MARGIN(A,B,C,D)</B></FONT><FONT 
face="Comic Sans MS" size=2> retorna los valores de margen de ganancia (Gm), 
margen de fase (Pm), frecuencia de cruce de ganancia (Wcg) y la frecuencia de 
cruce de fase (Wcp) cuando se trabaja con las matrices de estado 
(A,B,C,D).</P></FONT><B><FONT size=2>
<P align=justify>[Gm,Pm,Wcg,Wcp] = MARGIN(NUM,DEN)</B></FONT><FONT 
face="Comic Sans MS" size=2> cuando se trabaja con la función de 
transferencia.</P></FONT><B><FONT size=2>
<P align=justify>[Gm,Pm,Wcg,Wcp] = MARGIN(MAG,PHASE,W)</B></FONT><FONT 
face="Comic Sans MS" size=2> toma los vectores de magnitud, fase y frecuencia 
del diagrama de Bode.</P></FONT><B><FONT size=2>
<P align=justify>MARGIN(A,B,C,D)</B></FONT><FONT face="Comic Sans MS" size=2> 
dibuja el diagrama de Bode y muestra con líneas verticales los márgenes 
deganancia y de fase.</P>
<P align=justify>&nbsp;</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;num=10;</P>
<P align=justify>&gt;&gt;den=[1 0.25 1];</P>
<P align=justify>&gt;&gt;[Gm,Pm,Wcg,Wcp] =margin(num,den)</P>
<P align=justify>Gm =</P>
<P align=justify>Inf</P>
<P align=justify>Pm =</P>
<P align=justify>4.7487</P>
<P align=justify>Wcg =</P>
<P align=justify>NaN</P>
<P align=justify>Wcp =</P>
<P align=justify>3.3114</P>
<P align=justify>&gt;&gt;margin(num,den)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>8.3 Lugar de las raíces</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Para obtener el lugar de las raíces de un sistema como el 
mostrado en el siguiente diagrama:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Se debe determinar su ecuación característica, la cual es de la 
forma:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Para obtener el lugar de las raíces, MatLab dispone del comando 
rlocus. Las diferentes </P><U>
<P align=justify>Sintaxis</U> para utilizar este comando son:</P></FONT><B><FONT 
size=2>
<P align=justify>rlocus(NUM,DEN)</B></FONT><FONT face="Comic Sans MS" size=2> 
calcula y dibuja el lugar de las raíces cuando se trabaja con la función de 
transferencia donde NUM y DEN son los vectores de los coeficientes en potencia 
descendiente de S de los polinomios del numerador y denominador de la función de 
transferencia G(S). MatLab generará automáticamente un conjunto de valores de la 
ganancia K.</P></FONT><B><FONT size=2>
<P align=justify>rlocus(NUM,DEN,K):</B></FONT><FONT face="Comic Sans MS" size=2> 
calcula y dibuja el lugar de las raíces cuando se trabaja con la función de 
transferencia y ha sido previamente definido el rango de valores de K. Por 
ejemplo de 0 a 100 con incrementos de 10: k=0:10:100</P></FONT><B><FONT size=2>
<P align=justify>R = rlocus(NUM,DEN,K) o [R,K] = rlocus(NUM,DEN)</B></FONT><FONT 
face="Comic Sans MS" size=2> no dibuja el lugar de las raíces pero almacena en 
la matriz R, de longitud igual al número de elementos de K, la localización de 
las raíces. R tendrá tantas columnas como raíces existan, estas pueden además 
ser complejas.</P></FONT><B><FONT size=2>
<P align=justify>rlocus(A,B,C,D), R=rlocus(A,B,C,D,K), o 
[R,K]=rlocus(A,B,C,D)</B></FONT><FONT face="Comic Sans MS" size=2> son 
equivalentes a las Sintaxis anteriores pero empleando las matrices de estado 
para hallar el lugar de las raíces.</P>
<P align=justify>Para la siguiente forma modificada de la ecuación 
característica de un sistema se desea hallar el lugar de las raíces mediante 
MatLab:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;num=[0,0,0,1];</P>
<P align=justify>&gt;&gt;den=[1,3,2,0];</P>
<P align=justify>&gt;&gt;rlocus(num,den)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>MatLab dispone del comando </FONT><FONT 
size=2>rlocfind</FONT><FONT face="Comic Sans MS" size=2> que permite determinar 
los polos del sistema para una valor determinado de k. Su </P><U>
<P align=justify>Sintaxis</U> es:</P></FONT><B><FONT size=2>
<P align=justify>[K,POLES] = rlocfind(num,den</B></FONT><FONT 
face="Comic Sans MS" size=2>) permite determinar los polos para un valor 
determinado de k, cuando se trabaja con la función de transferencia. Por medio 
del curso en el lugar de las raíces se selecciona una localización, MatLab 
retorna el valor de k para esta localización y los polos asociados a esta 
ganancia.</P>
<P align=justify>&nbsp;</P>
<P align=justify>Cuando se trabaja con las matrices de estado, las Sintaxis para 
el comando rlocfind es: </FONT><B><FONT size=2>[K,POLES] = 
rlocfind(A,B,C,D).</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Al ejecutar el comando </FONT><FONT size=2>rlocfind</FONT><FONT 
face="Comic Sans MS" size=2> con la función de transferencia anterior, MatLab 
activa la ventana de figuras en espera de que el usuario seleccione un punto del 
lugar de las raíces mediante el cursor. En este caso el punto seleccionado fue 
-2.4623 en la parte real y - 0.0132 en la parte imaginaria.</P></FONT><FONT 
size=2>
<P align=justify>» [k,poles]=rlocfind(num,den)</P>
<P align=justify>Select a point in the graphics window</P>
<P align=justify>selected_point =</P>
<P align=justify>-2.4623 - 0.0132i</P>
<P align=justify>k =</P>
<P align=justify>1.6655</P>
<P align=justify>poles =</P>
<P align=justify>-2.4625</P>
<P align=justify>-0.2688 + 0.7773i</P>
<P align=justify>-0.2688 - 0.7773i</P>
<P align=justify>&nbsp;</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>Para seleccionar el punto en el cual calcular los polos del 
lugar de las raíces sin usar el cursor se agrega un parámetro al comando 
rlocfind. Este debe ser el punto o los puntos en donde se desea tomar el valor 
de k. La nueva </P><U>
<P align=justify>Sintaxis</U> es: </P></FONT><B><FONT size=2>
<P align=justify>[K,POLES] = rlocfind(A,B,C,D,P) o [K,POLES] = 
rlocfind(num,den,P)</P></B></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>P debe definirse previamente indicando la parte real e 
imaginaria del mismo. Por ejemplo: P=3+0i o P=1-0.555i.</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P></FONT><B><FONT face="Comic Sans MS">
<P align=justify>8.4 Controladores PID</P></B></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>Para implementar los diferentes tipos de controladores (P, PD, 
PI, PID) en MatLab se hace uso de la función de transferencia propia del sistema 
a objeto de estudio. Si dicho sistema es de la forma:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>donde G(S) es la función de transferencia de la planta o 
proceso; mientras que C(S) es la función de transferencia del controlador.</P>
<P align=justify>Para el caso del controlador proporcional, C(S)=Kp, que es una 
constante o valor escalar. El controlador PI es C(S)=Kp + Ki/S que puede 
representarse como una relación ente dos polinomios.</P>
<P align=justify>El controlador PID es C(S)=Kp + Ki/S + Kd S que se representa 
como:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>que es de nuevo una relación entre dos polinomios. Los 
coeficientes decrecientes en potencias de S de estos polinomio pueden ser 
almacenados en vectores en MatLab. Si se multiplica el controlador C(S) por la 
función de transferencia del proceso o planta G(S) se formará la función de 
transferencia de lazo abierto. Por ejemplo un G(S) puede ser:</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>Para obtener la respuesta en lazo abierto ante una entrada 
escalón unitario tenemos:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;Kp=50;</P>
<P align=justify>&gt;&gt;Ki=1;</P>
<P align=justify>&gt;&gt;Kd=10;</P>
<P align=justify>&gt;&gt;num=[Kd Kp Ki];</P>
<P align=justify>&gt;&gt;den=[1 10 20 0 0];</P>
<P align=justify>&gt;&gt;step(num,den)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Para obtener la respuesta de lazo cerrado en el tiempo para una 
entrada escalón unitario se emplea el comando cloop, el cual genera los 
polinomios del numerador (numc) y denominador (denc) de la función de 
transferencia de lazo cerrado con realimentación unitaria a partir de los 
polinomios de la función de transferencia de lazo abierto (num y den). Su 
</P><U>
<P align=justify>Sintaxis</U> es: </P></FONT><B><FONT size=2>
<P align=justify>[numc,denc]=cloop(num,den,sign)</P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>El signo de la realimentación viene dado por sign. Para el 
ejemplo anterior, tenemos:</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;Kp=500;</P>
<P align=justify>&gt;&gt;Ki=1;</P>
<P align=justify>&gt;&gt;Kd=100;</P>
<P align=justify>&gt;&gt;num1=[Kd Kp Ki];</P>
<P align=justify>&gt;&gt;den1=[1 0];</P>
<P align=justify>&gt;&gt;num2=1;</P>
<P align=justify>&gt;&gt;den2=[1 10 20 0];</P>
<P 
align=justify>&gt;&gt;[numc,numd]=cloop(conv(num1,num2),conv(den1,den2),-1);</P>
<P align=justify>&gt;&gt;step(numc,denc)</P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Se usa el comando </FONT><FONT size=2>conv</FONT><FONT 
face="Comic Sans MS" size=2> para obtener la convolución y multiplicación 
polinomial de dos vectores. La salida obtenida mediante el comando </FONT><FONT 
size=2>step</FONT><FONT face="Comic Sans MS" size=2> se muestra a 
continuación:</P>
<P align=justify>&nbsp;</P>
<P align=justify></P></FONT><B><I><FONT face=Arial>
<P align=justify>9. Trucos en MATLAB®</P></I></FONT><FONT face="Comic Sans MS">
<P align=justify>Paper semilogarítmico gratis: papelbod.m </P></B></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>Para cotejar sus diagramas de Bode: </P></FONT><FONT size=2>
<P align=justify>&gt;&gt;bode(num,den) </P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>donde </FONT><FONT size=2>num</FONT><FONT face="Comic Sans MS" 
size=2> y </FONT><FONT size=2>den</FONT><FONT face="Comic Sans MS" size=2> son 
vectores que contienen los coeficientes del numerador y denominador de H(s) en 
orden de potencias descendentes de s. </P>
<P align=justify></P>
<P align=justify>Nota: Esto da las curvas exactas, no las aproximaciones 
asintóticas con líneas rectas. </P>
<P align=justify>&nbsp;</P>
<P align=justify>Ejemplo: Para , </P>
<P align=justify>&nbsp;</P>
<P align=justify></P>
<P align=justify>&nbsp;</P>
<P align=justify>Escribimos </P></FONT><FONT size=2>
<P align=justify>&gt;&gt;bode([158.11 15.811],[1 5 0]) </P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P><B>
<P align=justify>Precaución:</B> El punto "." puede significar operación 
elemento-por-elemento o punto decimal.</P>
<P align=justify>Cuando escribimos un dígito pegado al punto como "2.", el 
interpretador cree que es el número "2.0". Entonces si queremos calcular A2B2, 
donde A y B son arreglos y no matrices (o sea, queremos operación 
elemento-por-elemento), debemos escribir </P></FONT><FONT size=2>
<P align=justify>&gt;&gt;A.^2 .*B.^2 (notar el espacio después del primer 2) 
</P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>y no </P></FONT><FONT size=2>
<P align=justify>&gt;&gt;A.^2.*B.^2 </P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>&nbsp;</P>
<P align=justify>Para remover ejes de la gráfica: </P></FONT><FONT size=2>
<P align=justify>&gt;&gt;set(gca,'Visible','off') </P></FONT><FONT 
face="Comic Sans MS" size=2>
<P align=justify>o simplemente </P></FONT><FONT size=2>
<P align=justify>&gt;&gt;axis off </P></FONT><FONT face="Comic Sans MS" size=2>
<P align=justify>&nbsp;</P>
<P align=justify></P>
<P align=justify>&nbsp;</P>
<P align=justify>Para cambiar el color de trasfondo de la gráfica: 
</P></FONT><FONT size=2>
<P align=justify>&gt;&gt; whitebg('c') </P></FONT><FONT face="Comic Sans MS" 
size=2>
<P align=justify>donde c es el código del color descrito en help plot. </P>
<P align=justify>&nbsp;</P>
<P align=justify>Para establecer propiedades de la gráfica, es más fácil hacerlo 
al crearla que después. Por ejemplo, para graficar con una línea gruesa, 
</P></FONT><FONT size=2>
<P align=justify>&gt;&gt;plot(x,y,'linewidth',3)</FONT><FONT 
face="Comic Sans MS" size=2> (En el momento de creación) </P></FONT><FONT 
size=2>
<P align=justify>&gt;&gt;set(get(gca,'children'),'linewidth',3)</FONT><FONT 
face="Comic Sans MS" size=2> (Después de creada) </P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify>&nbsp;</P>
<P align=justify></P>
<P align=justify>&nbsp;</P></FONT></BODY></HTML>
